package app.actors

import java.util.UUID

import akka.actor._
import akka.event.LoggingReceive
import app.actors.NetClient.Management.{SessionToken, PlainPassword, Credentials}
import app.actors.game.GameActor
import app.models._
import app.models.game.Human
import app.persistence.tables.Tables
import implicits._
import app.persistence.DBDriver._

import scala.util.Try

object NetClient {
  type GameInMsg = Human => GameActor.In

  object Management {
    sealed trait AuthToken

    case class SessionToken(value: String) extends AuthToken
    object SessionToken {
      def random() = SessionToken(UUID.randomUUID().shortStr)
    }

    case class PlainPassword(value: String) extends AuthToken {
      import com.github.t3hnar.bcrypt._

      def encrypted = value.bcrypt
      def check(hash: String) = value.isBcrypted(hash)
    }

    case class Credentials(name: String, auth: AuthToken) {
      def check(sessionToken: String, passwordHash: String): Boolean =
        auth match {
          case SessionToken(token) => sessionToken == token
          case password: PlainPassword => password.check(passwordHash)
        }
    }

    sealed trait In
    object In {
      case object AutoRegister extends In
      case class CheckNameAvailability(name: String) extends In
      case class ChangeCredentials(username: String, password: PlainPassword) extends In
      case class Login(credentials: Credentials) extends In
      case object JoinGame extends In
    }

    sealed trait Out
    object Out {
      case class CheckNameAvailabilityResponse(name: String, available: Boolean) extends Out
      case class ChangeCredentialsResponse(newToken: Option[SessionToken]) extends Out

      sealed trait LoginResponse extends Out
      case object InvalidCredentials extends LoginResponse
      case class LoggedIn(
        user: User, token: SessionToken, autogenerated: Boolean
      ) extends LoginResponse

      case class GameJoined(human: Human) extends Out
    }
  }

  object Msgs {
    sealed trait FromClient
    object FromClient {
      case class Game(msg: GameInMsg) extends FromClient
      case class Management(msg: NetClient.Management.In) extends FromClient
    }

    sealed trait FromServer
    object FromServer {
      case class Game(msg: GameActor.ClientOut) extends FromServer
      case class Management(msg: NetClient.Management.Out) extends FromServer
    }
  }
}

class NetClient(
  msgHandler: ActorRef, gamesManager: ActorRef, db: Database
) extends Actor with ActorLogging {
  import app.actors.NetClient.Management.In._
  import app.actors.NetClient.Management.Out._
  import app.actors.NetClient.Msgs._
  import app.actors.NetClient._

  implicit class ServerMsgExts(msg: FromServer) {
    def out(): Unit = msgHandler ! msg
  }
  implicit class ManagementMsgExts(msg: Management.Out) {
    def out(): Unit = FromServer.Management(msg).out()
  }
  implicit class GameMsgExts(msg: GameActor.ClientOut) {
    def out(): Unit = FromServer.Game(msg).out()
  }

  context.watch(msgHandler)

  override def receive = notLoggedIn

  private[this] def common: Receive = new Receive {
    override def isDefinedAt(x: Any) = false
    override def apply(v1: Any) = ???
  }

  private[this] def notLoggedIn: Receive = {
    def logIn(user: User, sessionToken: SessionToken, autogenerated: Boolean): Unit = {
      context.become(loggedIn(user))
      LoggedIn(user, sessionToken, autogenerated).out()
    }

    LoggingReceive(({
      case FromClient.Management(AutoRegister) =>
        val password = PlainPassword(UUID.randomUUID().shortStr)
        val sessionToken = SessionToken.random()
        val id = UUID.randomUUID()
        val user = User(id, s"autogen-${id.shortStr}")
        val credentials = Credentials(user.name, password)
        db.withSession { implicit session =>
          Tables.users.map(t => (t.user, t.autogenerated, t.sessionToken, t.password)).
            insert((user, true, sessionToken.value, password.encrypted))
        }
        logIn(user, sessionToken, autogenerated = true)

      case FromClient.Management(Login(credentials)) =>
        val optQ = Tables.users.
          filter(t => t.name === credentials.name).
          map(t => (t.id, t.sessionToken, t.autogenerated, t.password))
        val idOpt = db.withSession(optQ.firstOption(_)).filter {
          case (_, sessionToken, _, pwHash) =>
            credentials.check(sessionToken, pwHash)
        }.map(t => (t._1, SessionToken(t._2), t._3))

        idOpt.fold2(
          InvalidCredentials.out(),
          { case (id, token, autogenerated) =>
            logIn(User(id, credentials.name), token, autogenerated) }
        )
    }: Receive) orElse common)
  }

  private[this] def loggedIn(user: User): Receive = LoggingReceive(({
    case FromClient.Management(CheckNameAvailability(name)) =>
      val query = Tables.users.map(_.name).filter(_ === name).exists
      val exists = db.withSession(query.run(_))
      CheckNameAvailabilityResponse(name, ! exists).out()

    case FromClient.Management(ChangeCredentials(username, password)) =>
      val token = SessionToken.random()
      val query = Tables.users.
        filter(t => t.id === user.id && t.autogenerated === true).
        map(t => (t.name, t.password, t.sessionToken, t.autogenerated))
      val success = Try {
        db.withSession(query.update((
          username, token.value, password.encrypted, false
        ))(_))
      }.getOrElse(0) === 1
      ChangeCredentialsResponse(if (success) Some(token) else None).out()

    case FromClient.Management(JoinGame) =>
      gamesManager ! GameActor.In.Join(user)

    case GameActor.Out.Joined(human, game) =>
      GameJoined(human).out()
      context.become(inGame(user, human, game))
  }: Receive) orElse common)

  private[this] def inGame(user: User, human: Human, game: ActorRef): Receive = {
    context.watch(game)
    LoggingReceive(({
      case FromClient.Game(msgFn) =>
        val msg = msgFn(human)
        game ! msg
      case msg: GameActor.ClientOut =>
        msg.out()
      case Terminated if sender() == game =>
        log.error("Game was terminated")
        context.become(loggedIn(user))
    }: Receive) orElse common)
  }
}


