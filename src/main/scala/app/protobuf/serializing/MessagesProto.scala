package app.protobuf.serializing

import akka.util.ByteString
import app.actors.NetClient
import app.actors.game.GameActor
import app.actors.net_client.ControlSecretKey
import com.trueaccord.scalapb.GeneratedMessage
import netmsg._

import scala.language.implicitConversions

trait MessagesProto extends Helpers { _: GameProto =>
  implicit def convert(msg: GameActor.NetClientOut.Events): game.MEvents =
    game.MEvents(convertSeq(msg.events))

  implicit def convert(msg: GameActor.NetClientOut.Error): game.MError =
    game.MError(msg.error)

  implicit def convert(msg: NetClient.LoggedInState.GameJoined): game.MJoined =
    game.MJoined(msg.human)

  implicit def convert(msg: GameActor.NetClientOut.Init): game.MInit =
    game.MInit(
      id = msg.id, bounds = msg.bounds,
      objects = convertSeq(msg.objects.objects),
      warpZone = convertSeq(msg.warpZonePoints),
      visiblePoints = convertSeq(msg.visiblePoints),
      selfTeam = msg.selfTeam, otherTeams = convertSeq(msg.otherTeams),
      self = msg.self, otherPlayers = convertSeq(msg.others)(convert),
      warpableObjectStats = convertWarpableStats(msg.warpableObjects),
      objectives = msg.objectives,
      turnStarted = msg.currentTurn,
      extractionSpeedRates = convertSeq(msg.extractionSpeeds)(convertInit)
    )

  implicit def convert(out: GameActor.NetClientOut): game.FromServer =
    out match {
      case msg: GameActor.NetClientOut.Events => game.FromServer(events = Some(msg))
      case msg: GameActor.NetClientOut.Error => game.FromServer(error = Some(msg))
      case msg: GameActor.NetClientOut.Init => game.FromServer(init = Some(msg))
    }

  implicit def convert(
    out: NetClient.LoggedInState.CheckNameAvailabilityResponse
  ): management.CheckNameAvailabilityResponse =
    management.CheckNameAvailabilityResponse(out.name, out.available)

  implicit def convert(
    out: NetClient.LoggedInState.RegisterResponse
  ): management.RegisterResponse =
    management.RegisterResponse(out.newToken.map(_.value))

  implicit def convert(
    out: NetClient.NotLoggedInState.LoginResponse
  ): management.LoginResponse =
    out match {
      case NetClient.NotLoggedInState.LoginResponse.InvalidCredentials =>
        management.LoginResponse()
      case NetClient.NotLoggedInState.LoginResponse.LoggedIn(user, token, autogenerated) =>
        management.LoginResponse(Some(management.LoginResponse.Data(
          id = user.id, username = user.name, sessionToken = token.value,
          autogenerated = autogenerated
        )))
    }

  def convertMgmtGameJoined(
    out: NetClient.LoggedInState.GameJoined
  ): management.GameJoined =
    management.GameJoined(out.human)

  implicit def convert(out: NetClient.ManagementOut): management.FromServer =
    out match {
      case msg: NetClient.LoggedInState.CheckNameAvailabilityResponse =>
        management.FromServer(checkNameAvailability = Some(msg))
      case msg: NetClient.LoggedInState.RegisterResponse =>
        management.FromServer(register = Some(msg))
      case msg: NetClient.NotLoggedInState.LoginResponse =>
        management.FromServer(login = Some(msg))
      case msg: NetClient.LoggedInState.GameJoined =>
        management.FromServer(gameJoined = Some(convertMgmtGameJoined(msg)))
      case NetClient.LoggedInState.JoinGameCancelled =>
        management.FromServer(gameJoinCancelled = Some(management.JoinGameCancelled()))
      case NetClient.LoggedInState.WaitingListJoined(token) =>
        management.FromServer(
          waitingListJoined = Some(management.WaitingListJoined(token.value))
        )
    }

  implicit def convert(out: NetClient.MsgHandlerConnectionIn.TimeSyncReply)
  : messages.TimeSync.FromServer =
    messages.TimeSync.FromServer(clientNow = out.clientNow, serverNow = out.serverNow)

  implicit def convert(out: NetClient.GameClientOut): messages.FromServer =
    out match {
      case msg: NetClient.NotLoggedInState.ProtoVersionCheckReply =>
        messages.FromServer(protoVersionCheck = Some(
          messages.ProtoVersionCheck.FromServer(msg.checksum)
        ))
      case msg: NetClient.InGameState.FromGameActor =>
        messages.FromServer(game = Some(msg.msg))
      case msg: NetClient.ManagementOut =>
        messages.FromServer(management = Some(msg))
      case msg: NetClient.MsgHandlerConnectionIn.TimeSyncReply =>
        messages.FromServer(timeSync = Some(msg))
    }

  implicit def convert(msg: NetClient.Control): control.Client2Server = {
    implicit def convert(key: ControlSecretKey): control.ControlSecretKey =
      control.ControlSecretKey(key.key)

    msg.msg match {
      case NetClient.Control.In.Shutdown =>
        control.Client2Server(msg.key, shutdown = Some(control.ShutdownReq()))
      case NetClient.Control.In.Status =>
        control.Client2Server(msg.key, status = Some(control.StatusReq()))
    }
  }

  implicit def convert(out: NetClient.Control.Out): control.Server2Client =
    out match {
      case NetClient.Control.Out.GenericReply(success, messageOpt) =>
        control.Server2Client(reply = Some(control.GenericReply(success, messageOpt)))
      case NetClient.Control.Out.Status(clients, playingUsers, games) =>
        control.Server2Client(status = Some(control.StatusReply(
          clients.map(convert), playingUsers.map(convert), games.map(convert)
        )))
    }

  def serializeGame(out: NetClient.GameClientOut): ByteString =
    serializeGenMsg(convert(out))
  def serializeControl(out: NetClient.Control): ByteString =
    serializeGenMsg(convert(out))
  def serializeControl(out: NetClient.Control.Out): ByteString =
    serializeGenMsg(convert(out))

  def serialize(out: NetClient.MsgHandlerOut): ByteString = out match {
    case m: NetClient.GameClientOut => serializeGame(m)
    case m: NetClient.Control.Out => serializeControl(m)
  }

  def serializeGenMsg(m: GeneratedMessage): ByteString = ByteString(m.toByteArray)
}
