// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!

package netmsg.game


import com.trueaccord.scalapb.Descriptors

final case class WObjectStats(
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[WObjectStats] with com.trueaccord.lenses.Updatable[WObjectStats] {
    lazy val serializedSize: Int = {
      var __size = 0
      __size
    }
    def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
    }
    def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats = {
      var _done__ = false
      while (!_done__) {
        val _tag__ = __input.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case tag => __input.skipField(tag)
        }
      }
      netmsg.game.WObjectStats(
      )
    }
    def getField(__field: Descriptors.FieldDescriptor): Any = throw new MatchError(__field)
    def companion = netmsg.game.WObjectStats
}

object WObjectStats extends com.trueaccord.scalapb.GeneratedMessageCompanion[WObjectStats]  {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[WObjectStats]  = this
  def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats = netmsg.game.WObjectStats(
  )
  lazy val descriptor = new Descriptors.MessageDescriptor("WObjectStats", this,
    None, m = Seq(netmsg.game.WObjectStats.Base.descriptor, netmsg.game.WObjectStats.SizedObj.descriptor, netmsg.game.WObjectStats.OwnedObj.descriptor, netmsg.game.WObjectStats.GivingActions.descriptor, netmsg.game.WObjectStats.Warpable.descriptor, netmsg.game.WObjectStats.SpecialAction.descriptor, netmsg.game.WObjectStats.Fighter.descriptor, netmsg.game.WObjectStats.Movable.descriptor, netmsg.game.WObjectStats.GivingPopulation.descriptor, netmsg.game.WObjectStats.Asteroid.descriptor, netmsg.game.WObjectStats.Rock.descriptor, netmsg.game.WObjectStats.Crystal.descriptor, netmsg.game.WObjectStats.Brush.descriptor, netmsg.game.WObjectStats.WarpGate.descriptor, netmsg.game.WObjectStats.Extractor.descriptor, netmsg.game.WObjectStats.PopulationTower.descriptor, netmsg.game.WObjectStats.ActionTower.descriptor, netmsg.game.WObjectStats.WarpLinker.descriptor, netmsg.game.WObjectStats.Spawner.descriptor, netmsg.game.WObjectStats.LaserTower.descriptor, netmsg.game.WObjectStats.Corvette.descriptor, netmsg.game.WObjectStats.WarpPrism.descriptor, netmsg.game.WObjectStats.Drone.descriptor, netmsg.game.WObjectStats.Wasp.descriptor, netmsg.game.WObjectStats.Scout.descriptor, netmsg.game.WObjectStats.RayShip.descriptor, netmsg.game.WObjectStats.RocketFrigate.descriptor, netmsg.game.WObjectStats.RocketFrigateDeployed.descriptor, netmsg.game.WObjectStats.Gunship.descriptor, netmsg.game.WObjectStats.Fortress.descriptor, netmsg.game.WObjectStats.VpTower.descriptor),
    e = Seq(),
    f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats"))
  lazy val defaultInstance = netmsg.game.WObjectStats(
  )
  final case class Base(
      blocksMovement: Boolean
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Base] with com.trueaccord.lenses.Updatable[Base] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += com.google.protobuf.CodedOutputStream.computeBoolSize(1, blocksMovement)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeBool(1, blocksMovement)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Base = {
        var __blocksMovement = this.blocksMovement
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __blocksMovement = __input.readBool()
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Base(
            blocksMovement = __blocksMovement
        )
      }
      def withBlocksMovement(__v: Boolean): Base = copy(blocksMovement = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => blocksMovement
        }
      }
      def companion = netmsg.game.WObjectStats.Base
  }
  
  object Base extends com.trueaccord.scalapb.GeneratedMessageCompanion[Base]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Base]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Base = netmsg.game.WObjectStats.Base(
      blocksMovement = fieldsMap(1).asInstanceOf[Boolean]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Base", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Base"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Base(
      blocksMovement = false
    )
    implicit class BaseLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Base]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Base](_l) {
      def blocksMovement: com.trueaccord.lenses.Lens[UpperPB, Boolean] = field(_.blocksMovement)((c_, f_) => c_.copy(blocksMovement = f_))
    }
    final val BLOCKS_MOVEMENT_FIELD_NUMBER = 1
  }
  
  final case class SizedObj(
      size: netmsg.base.Vect2
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[SizedObj] with com.trueaccord.lenses.Updatable[SizedObj] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(size.serializedSize) + size.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(size.serializedSize)
        size.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.SizedObj = {
        var __size = this.size
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __size = com.trueaccord.scalapb.LiteParser.readMessage(__input, __size)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.SizedObj(
            size = __size
        )
      }
      def withSize(__v: netmsg.base.Vect2): SizedObj = copy(size = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => size
        }
      }
      def companion = netmsg.game.WObjectStats.SizedObj
  }
  
  object SizedObj extends com.trueaccord.scalapb.GeneratedMessageCompanion[SizedObj]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[SizedObj]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.SizedObj = netmsg.game.WObjectStats.SizedObj(
      size = fieldsMap(1).asInstanceOf[netmsg.base.Vect2]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("SizedObj", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.SizedObj"))
    lazy val defaultInstance = netmsg.game.WObjectStats.SizedObj(
      size = netmsg.base.Vect2.defaultInstance
    )
    implicit class SizedObjLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, SizedObj]) extends com.trueaccord.lenses.ObjectLens[UpperPB, SizedObj](_l) {
      def size: com.trueaccord.lenses.Lens[UpperPB, netmsg.base.Vect2] = field(_.size)((c_, f_) => c_.copy(size = f_))
    }
    final val SIZE_FIELD_NUMBER = 1
  }
  
  final case class OwnedObj(
      isCritical: Boolean,
      visibility: Int,
      maxHp: Int,
      kind: netmsg.game.WObjKind,
      isRespawnable: Boolean,
      maxDamagePerHit: Option[Int] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[OwnedObj] with com.trueaccord.lenses.Updatable[OwnedObj] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += com.google.protobuf.CodedOutputStream.computeBoolSize(1, isCritical)
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(2, visibility)
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(3, maxHp)
        __size += com.google.protobuf.CodedOutputStream.computeEnumSize(4, kind.id)
        __size += com.google.protobuf.CodedOutputStream.computeBoolSize(5, isRespawnable)
        if (maxDamagePerHit.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(6, maxDamagePerHit.get) }
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeBool(1, isCritical)
        output.writeUInt32(2, visibility)
        output.writeUInt32(3, maxHp)
        output.writeEnum(4, kind.id)
        output.writeBool(5, isRespawnable)
        maxDamagePerHit.foreach { v => 
          output.writeUInt32(6, v)
        }
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.OwnedObj = {
        var __isCritical = this.isCritical
        var __visibility = this.visibility
        var __maxHp = this.maxHp
        var __kind = this.kind
        var __isRespawnable = this.isRespawnable
        var __maxDamagePerHit = this.maxDamagePerHit
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __isCritical = __input.readBool()
            case 16 =>
              __visibility = __input.readUInt32()
            case 24 =>
              __maxHp = __input.readUInt32()
            case 32 =>
              __kind = netmsg.game.WObjKind.fromValue(__input.readEnum())
            case 40 =>
              __isRespawnable = __input.readBool()
            case 48 =>
              __maxDamagePerHit = Some(__input.readUInt32())
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.OwnedObj(
            isCritical = __isCritical,
            visibility = __visibility,
            maxHp = __maxHp,
            kind = __kind,
            isRespawnable = __isRespawnable,
            maxDamagePerHit = __maxDamagePerHit
        )
      }
      def withIsCritical(__v: Boolean): OwnedObj = copy(isCritical = __v)
      def withVisibility(__v: Int): OwnedObj = copy(visibility = __v)
      def withMaxHp(__v: Int): OwnedObj = copy(maxHp = __v)
      def withKind(__v: netmsg.game.WObjKind): OwnedObj = copy(kind = __v)
      def withIsRespawnable(__v: Boolean): OwnedObj = copy(isRespawnable = __v)
      def getMaxDamagePerHit: Int = maxDamagePerHit.getOrElse(0)
      def clearMaxDamagePerHit: OwnedObj = copy(maxDamagePerHit = None)
      def withMaxDamagePerHit(__v: Int): OwnedObj = copy(maxDamagePerHit = Some(__v))
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => isCritical
          case 2 => visibility
          case 3 => maxHp
          case 4 => kind
          case 5 => isRespawnable
          case 6 => maxDamagePerHit
        }
      }
      def companion = netmsg.game.WObjectStats.OwnedObj
  }
  
  object OwnedObj extends com.trueaccord.scalapb.GeneratedMessageCompanion[OwnedObj]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[OwnedObj]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.OwnedObj = netmsg.game.WObjectStats.OwnedObj(
      isCritical = fieldsMap(1).asInstanceOf[Boolean],
      visibility = fieldsMap(2).asInstanceOf[Int],
      maxHp = fieldsMap(3).asInstanceOf[Int],
      kind = fieldsMap(4).asInstanceOf[netmsg.game.WObjKind],
      isRespawnable = fieldsMap(5).asInstanceOf[Boolean],
      maxDamagePerHit = fieldsMap.getOrElse(6, None).asInstanceOf[Option[Int]]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("OwnedObj", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.OwnedObj"))
    lazy val defaultInstance = netmsg.game.WObjectStats.OwnedObj(
      isCritical = false,
      visibility = 0,
      maxHp = 0,
      kind = netmsg.game.WObjKind.LIGHT,
      isRespawnable = false
    )
    implicit class OwnedObjLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, OwnedObj]) extends com.trueaccord.lenses.ObjectLens[UpperPB, OwnedObj](_l) {
      def isCritical: com.trueaccord.lenses.Lens[UpperPB, Boolean] = field(_.isCritical)((c_, f_) => c_.copy(isCritical = f_))
      def visibility: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.visibility)((c_, f_) => c_.copy(visibility = f_))
      def maxHp: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.maxHp)((c_, f_) => c_.copy(maxHp = f_))
      def kind: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjKind] = field(_.kind)((c_, f_) => c_.copy(kind = f_))
      def isRespawnable: com.trueaccord.lenses.Lens[UpperPB, Boolean] = field(_.isRespawnable)((c_, f_) => c_.copy(isRespawnable = f_))
      def maxDamagePerHit: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.getMaxDamagePerHit)((c_, f_) => c_.copy(maxDamagePerHit = Some(f_)))
      def optionalMaxDamagePerHit: com.trueaccord.lenses.Lens[UpperPB, Option[Int]] = field(_.maxDamagePerHit)((c_, f_) => c_.copy(maxDamagePerHit = f_))
    }
    final val IS_CRITICAL_FIELD_NUMBER = 1
    final val VISIBILITY_FIELD_NUMBER = 2
    final val MAX_HP_FIELD_NUMBER = 3
    final val KIND_FIELD_NUMBER = 4
    final val IS_RESPAWNABLE_FIELD_NUMBER = 5
    final val MAX_DAMAGE_PER_HIT_FIELD_NUMBER = 6
  }
  
  final case class GivingActions(
      actionsGiven: Int
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[GivingActions] with com.trueaccord.lenses.Updatable[GivingActions] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(1, actionsGiven)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeUInt32(1, actionsGiven)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.GivingActions = {
        var __actionsGiven = this.actionsGiven
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __actionsGiven = __input.readUInt32()
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.GivingActions(
            actionsGiven = __actionsGiven
        )
      }
      def withActionsGiven(__v: Int): GivingActions = copy(actionsGiven = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => actionsGiven
        }
      }
      def companion = netmsg.game.WObjectStats.GivingActions
  }
  
  object GivingActions extends com.trueaccord.scalapb.GeneratedMessageCompanion[GivingActions]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[GivingActions]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.GivingActions = netmsg.game.WObjectStats.GivingActions(
      actionsGiven = fieldsMap(1).asInstanceOf[Int]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("GivingActions", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.GivingActions"))
    lazy val defaultInstance = netmsg.game.WObjectStats.GivingActions(
      actionsGiven = 0
    )
    implicit class GivingActionsLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, GivingActions]) extends com.trueaccord.lenses.ObjectLens[UpperPB, GivingActions](_l) {
      def actionsGiven: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.actionsGiven)((c_, f_) => c_.copy(actionsGiven = f_))
    }
    final val ACTIONS_GIVEN_FIELD_NUMBER = 1
  }
  
  final case class Warpable(
      warpTime: Int,
      cost: Int,
      populationCost: Int,
      group: netmsg.game.WObjectStats.Warpable.Group
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Warpable] with com.trueaccord.lenses.Updatable[Warpable] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(1, warpTime)
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(2, cost)
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(3, populationCost)
        __size += com.google.protobuf.CodedOutputStream.computeEnumSize(4, group.id)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeUInt32(1, warpTime)
        output.writeUInt32(2, cost)
        output.writeUInt32(3, populationCost)
        output.writeEnum(4, group.id)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Warpable = {
        var __warpTime = this.warpTime
        var __cost = this.cost
        var __populationCost = this.populationCost
        var __group = this.group
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __warpTime = __input.readUInt32()
            case 16 =>
              __cost = __input.readUInt32()
            case 24 =>
              __populationCost = __input.readUInt32()
            case 32 =>
              __group = netmsg.game.WObjectStats.Warpable.Group.fromValue(__input.readEnum())
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Warpable(
            warpTime = __warpTime,
            cost = __cost,
            populationCost = __populationCost,
            group = __group
        )
      }
      def withWarpTime(__v: Int): Warpable = copy(warpTime = __v)
      def withCost(__v: Int): Warpable = copy(cost = __v)
      def withPopulationCost(__v: Int): Warpable = copy(populationCost = __v)
      def withGroup(__v: netmsg.game.WObjectStats.Warpable.Group): Warpable = copy(group = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => warpTime
          case 2 => cost
          case 3 => populationCost
          case 4 => group
        }
      }
      def companion = netmsg.game.WObjectStats.Warpable
  }
  
  object Warpable extends com.trueaccord.scalapb.GeneratedMessageCompanion[Warpable]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Warpable]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Warpable = netmsg.game.WObjectStats.Warpable(
      warpTime = fieldsMap(1).asInstanceOf[Int],
      cost = fieldsMap(2).asInstanceOf[Int],
      populationCost = fieldsMap(3).asInstanceOf[Int],
      group = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Warpable.Group]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Warpable", this,
      None, m = Seq(),
      e = Seq(netmsg.game.WObjectStats.Warpable.Group.descriptor),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Warpable"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Warpable(
      warpTime = 0,
      cost = 0,
      populationCost = 0,
      group = netmsg.game.WObjectStats.Warpable.Group.BUILDING
    )
    sealed trait Group extends com.trueaccord.scalapb.GeneratedEnum {
      def isBuilding: Boolean = false
      def isUnit: Boolean = false
    }
    
    object Group extends com.trueaccord.scalapb.GeneratedEnumCompanion[Group] {
      case object BUILDING extends Group {
        val id = 1
        val name = "BUILDING"
        override def isBuilding: Boolean = true
      }
      
      case object UNIT extends Group {
        val id = 2
        val name = "UNIT"
        override def isUnit: Boolean = true
      }
      
      lazy val values = Seq(BUILDING, UNIT)
      def fromValue(value: Int): Group = value match {
        case 1 => BUILDING
        case 2 => UNIT
      }
      lazy val descriptor = new Descriptors.EnumDescriptor(0, "Group", this)
    }
    implicit class WarpableLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Warpable]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Warpable](_l) {
      def warpTime: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.warpTime)((c_, f_) => c_.copy(warpTime = f_))
      def cost: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.cost)((c_, f_) => c_.copy(cost = f_))
      def populationCost: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.populationCost)((c_, f_) => c_.copy(populationCost = f_))
      def group: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable.Group] = field(_.group)((c_, f_) => c_.copy(group = f_))
    }
    final val WARP_TIME_FIELD_NUMBER = 1
    final val COST_FIELD_NUMBER = 2
    final val POPULATION_COST_FIELD_NUMBER = 3
    final val GROUP_FIELD_NUMBER = 4
  }
  
  final case class SpecialAction(
      actionsNeeded: Int
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[SpecialAction] with com.trueaccord.lenses.Updatable[SpecialAction] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(1, actionsNeeded)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeUInt32(1, actionsNeeded)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.SpecialAction = {
        var __actionsNeeded = this.actionsNeeded
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __actionsNeeded = __input.readUInt32()
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.SpecialAction(
            actionsNeeded = __actionsNeeded
        )
      }
      def withActionsNeeded(__v: Int): SpecialAction = copy(actionsNeeded = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => actionsNeeded
        }
      }
      def companion = netmsg.game.WObjectStats.SpecialAction
  }
  
  object SpecialAction extends com.trueaccord.scalapb.GeneratedMessageCompanion[SpecialAction]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[SpecialAction]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.SpecialAction = netmsg.game.WObjectStats.SpecialAction(
      actionsNeeded = fieldsMap(1).asInstanceOf[Int]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("SpecialAction", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.SpecialAction"))
    lazy val defaultInstance = netmsg.game.WObjectStats.SpecialAction(
      actionsNeeded = 0
    )
    implicit class SpecialActionLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, SpecialAction]) extends com.trueaccord.lenses.ObjectLens[UpperPB, SpecialAction](_l) {
      def actionsNeeded: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.actionsNeeded)((c_, f_) => c_.copy(actionsNeeded = f_))
    }
    final val ACTIONS_NEEDED_FIELD_NUMBER = 1
  }
  
  final case class Fighter(
      attack: netmsg.base.Range,
      attackOverrides: Seq[netmsg.game.WObjectStats.Fighter.AttackOverride] = Nil,
      attackRange: Float,
      attacks: Int
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Fighter] with com.trueaccord.lenses.Updatable[Fighter] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(attack.serializedSize) + attack.serializedSize
        attackOverrides.foreach(attackOverrides => __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(attackOverrides.serializedSize) + attackOverrides.serializedSize)
        __size += com.google.protobuf.CodedOutputStream.computeFloatSize(3, attackRange)
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(4, attacks)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(attack.serializedSize)
        attack.writeTo(output)
        attackOverrides.foreach { v => 
          output.writeTag(2, 2)
          output.writeRawVarint32(v.serializedSize)
          v.writeTo(output)
        }
        output.writeFloat(3, attackRange)
        output.writeUInt32(4, attacks)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Fighter = {
        var __attack = this.attack
        val __attackOverrides = (scala.collection.immutable.Vector.newBuilder[netmsg.game.WObjectStats.Fighter.AttackOverride] ++= this.attackOverrides)
        var __attackRange = this.attackRange
        var __attacks = this.attacks
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __attack = com.trueaccord.scalapb.LiteParser.readMessage(__input, __attack)
            case 18 =>
              __attackOverrides += com.trueaccord.scalapb.LiteParser.readMessage(__input, netmsg.game.WObjectStats.Fighter.AttackOverride.defaultInstance)
            case 29 =>
              __attackRange = __input.readFloat()
            case 32 =>
              __attacks = __input.readUInt32()
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Fighter(
            attack = __attack,
            attackOverrides = __attackOverrides.result(),
            attackRange = __attackRange,
            attacks = __attacks
        )
      }
      def withAttack(__v: netmsg.base.Range): Fighter = copy(attack = __v)
      def clearAttackOverrides = copy(attackOverrides = Nil)
      def addAttackOverrides(__vs: netmsg.game.WObjectStats.Fighter.AttackOverride*): Fighter = addAllAttackOverrides(__vs)
      def addAllAttackOverrides(__vs: TraversableOnce[netmsg.game.WObjectStats.Fighter.AttackOverride]): Fighter = copy(attackOverrides = attackOverrides ++ __vs)
      def withAttackOverrides(__v: Seq[netmsg.game.WObjectStats.Fighter.AttackOverride]): Fighter = copy(attackOverrides = __v)
      def withAttackRange(__v: Float): Fighter = copy(attackRange = __v)
      def withAttacks(__v: Int): Fighter = copy(attacks = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => attack
          case 2 => attackOverrides
          case 3 => attackRange
          case 4 => attacks
        }
      }
      def companion = netmsg.game.WObjectStats.Fighter
  }
  
  object Fighter extends com.trueaccord.scalapb.GeneratedMessageCompanion[Fighter]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Fighter]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Fighter = netmsg.game.WObjectStats.Fighter(
      attack = fieldsMap(1).asInstanceOf[netmsg.base.Range],
      attackOverrides = fieldsMap.getOrElse(2, Nil).asInstanceOf[Seq[netmsg.game.WObjectStats.Fighter.AttackOverride]],
      attackRange = fieldsMap(3).asInstanceOf[Float],
      attacks = fieldsMap(4).asInstanceOf[Int]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Fighter", this,
      None, m = Seq(netmsg.game.WObjectStats.Fighter.AttackOverride.descriptor),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Fighter"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Fighter(
      attack = netmsg.base.Range.defaultInstance,
      attackRange = 0.0f,
      attacks = 0
    )
    final case class AttackOverride(
        kind: netmsg.game.WObjKind,
        attack: netmsg.base.Range
        ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[AttackOverride] with com.trueaccord.lenses.Updatable[AttackOverride] {
        lazy val serializedSize: Int = {
          var __size = 0
          __size += com.google.protobuf.CodedOutputStream.computeEnumSize(1, kind.id)
          __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(attack.serializedSize) + attack.serializedSize
          __size
        }
        def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
          output.writeEnum(1, kind.id)
          output.writeTag(2, 2)
          output.writeRawVarint32(attack.serializedSize)
          attack.writeTo(output)
        }
        def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Fighter.AttackOverride = {
          var __kind = this.kind
          var __attack = this.attack
          var _done__ = false
          while (!_done__) {
            val _tag__ = __input.readTag()
            _tag__ match {
              case 0 => _done__ = true
              case 8 =>
                __kind = netmsg.game.WObjKind.fromValue(__input.readEnum())
              case 18 =>
                __attack = com.trueaccord.scalapb.LiteParser.readMessage(__input, __attack)
              case tag => __input.skipField(tag)
            }
          }
          netmsg.game.WObjectStats.Fighter.AttackOverride(
              kind = __kind,
              attack = __attack
          )
        }
        def withKind(__v: netmsg.game.WObjKind): AttackOverride = copy(kind = __v)
        def withAttack(__v: netmsg.base.Range): AttackOverride = copy(attack = __v)
        def getField(__field: Descriptors.FieldDescriptor): Any = {
          __field.number match {
            case 1 => kind
            case 2 => attack
          }
        }
        def companion = netmsg.game.WObjectStats.Fighter.AttackOverride
    }
    
    object AttackOverride extends com.trueaccord.scalapb.GeneratedMessageCompanion[AttackOverride]  {
      implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[AttackOverride]  = this
      def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Fighter.AttackOverride = netmsg.game.WObjectStats.Fighter.AttackOverride(
        kind = fieldsMap(1).asInstanceOf[netmsg.game.WObjKind],
        attack = fieldsMap(2).asInstanceOf[netmsg.base.Range]
      )
      lazy val descriptor = new Descriptors.MessageDescriptor("AttackOverride", this,
        None, m = Seq(),
        e = Seq(),
        f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Fighter.AttackOverride"))
      lazy val defaultInstance = netmsg.game.WObjectStats.Fighter.AttackOverride(
        kind = netmsg.game.WObjKind.LIGHT,
        attack = netmsg.base.Range.defaultInstance
      )
      implicit class AttackOverrideLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, AttackOverride]) extends com.trueaccord.lenses.ObjectLens[UpperPB, AttackOverride](_l) {
        def kind: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjKind] = field(_.kind)((c_, f_) => c_.copy(kind = f_))
        def attack: com.trueaccord.lenses.Lens[UpperPB, netmsg.base.Range] = field(_.attack)((c_, f_) => c_.copy(attack = f_))
      }
      final val KIND_FIELD_NUMBER = 1
      final val ATTACK_FIELD_NUMBER = 2
    }
    
    implicit class FighterLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Fighter]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Fighter](_l) {
      def attack: com.trueaccord.lenses.Lens[UpperPB, netmsg.base.Range] = field(_.attack)((c_, f_) => c_.copy(attack = f_))
      def attackOverrides: com.trueaccord.lenses.Lens[UpperPB, Seq[netmsg.game.WObjectStats.Fighter.AttackOverride]] = field(_.attackOverrides)((c_, f_) => c_.copy(attackOverrides = f_))
      def attackRange: com.trueaccord.lenses.Lens[UpperPB, Float] = field(_.attackRange)((c_, f_) => c_.copy(attackRange = f_))
      def attacks: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.attacks)((c_, f_) => c_.copy(attacks = f_))
    }
    final val ATTACK_FIELD_NUMBER = 1
    final val ATTACK_OVERRIDES_FIELD_NUMBER = 2
    final val ATTACK_RANGE_FIELD_NUMBER = 3
    final val ATTACKS_FIELD_NUMBER = 4
  }
  
  final case class Movable(
      movementRange: Int
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Movable] with com.trueaccord.lenses.Updatable[Movable] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(1, movementRange)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeUInt32(1, movementRange)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Movable = {
        var __movementRange = this.movementRange
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __movementRange = __input.readUInt32()
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Movable(
            movementRange = __movementRange
        )
      }
      def withMovementRange(__v: Int): Movable = copy(movementRange = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => movementRange
        }
      }
      def companion = netmsg.game.WObjectStats.Movable
  }
  
  object Movable extends com.trueaccord.scalapb.GeneratedMessageCompanion[Movable]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Movable]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Movable = netmsg.game.WObjectStats.Movable(
      movementRange = fieldsMap(1).asInstanceOf[Int]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Movable", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Movable"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Movable(
      movementRange = 0
    )
    implicit class MovableLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Movable]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Movable](_l) {
      def movementRange: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.movementRange)((c_, f_) => c_.copy(movementRange = f_))
    }
    final val MOVEMENT_RANGE_FIELD_NUMBER = 1
  }
  
  final case class GivingPopulation(
      populationGiven: Int
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[GivingPopulation] with com.trueaccord.lenses.Updatable[GivingPopulation] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(1, populationGiven)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeUInt32(1, populationGiven)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.GivingPopulation = {
        var __populationGiven = this.populationGiven
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __populationGiven = __input.readUInt32()
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.GivingPopulation(
            populationGiven = __populationGiven
        )
      }
      def withPopulationGiven(__v: Int): GivingPopulation = copy(populationGiven = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => populationGiven
        }
      }
      def companion = netmsg.game.WObjectStats.GivingPopulation
  }
  
  object GivingPopulation extends com.trueaccord.scalapb.GeneratedMessageCompanion[GivingPopulation]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[GivingPopulation]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.GivingPopulation = netmsg.game.WObjectStats.GivingPopulation(
      populationGiven = fieldsMap(1).asInstanceOf[Int]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("GivingPopulation", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.GivingPopulation"))
    lazy val defaultInstance = netmsg.game.WObjectStats.GivingPopulation(
      populationGiven = 0
    )
    implicit class GivingPopulationLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, GivingPopulation]) extends com.trueaccord.lenses.ObjectLens[UpperPB, GivingPopulation](_l) {
      def populationGiven: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.populationGiven)((c_, f_) => c_.copy(populationGiven = f_))
    }
    final val POPULATION_GIVEN_FIELD_NUMBER = 1
  }
  
  final case class Asteroid(
      base: netmsg.game.WObjectStats.Base
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Asteroid] with com.trueaccord.lenses.Updatable[Asteroid] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Asteroid = {
        var __base = this.base
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Asteroid(
            base = __base
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Asteroid = copy(base = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
        }
      }
      def companion = netmsg.game.WObjectStats.Asteroid
  }
  
  object Asteroid extends com.trueaccord.scalapb.GeneratedMessageCompanion[Asteroid]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Asteroid]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Asteroid = netmsg.game.WObjectStats.Asteroid(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Asteroid", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Asteroid"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Asteroid(
      base = netmsg.game.WObjectStats.Base.defaultInstance
    )
    implicit class AsteroidLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Asteroid]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Asteroid](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
    }
    final val BASE_FIELD_NUMBER = 1
  }
  
  final case class Rock(
      base: netmsg.game.WObjectStats.Base
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Rock] with com.trueaccord.lenses.Updatable[Rock] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Rock = {
        var __base = this.base
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Rock(
            base = __base
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Rock = copy(base = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
        }
      }
      def companion = netmsg.game.WObjectStats.Rock
  }
  
  object Rock extends com.trueaccord.scalapb.GeneratedMessageCompanion[Rock]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Rock]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Rock = netmsg.game.WObjectStats.Rock(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Rock", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Rock"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Rock(
      base = netmsg.game.WObjectStats.Base.defaultInstance
    )
    implicit class RockLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Rock]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Rock](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
    }
    final val BASE_FIELD_NUMBER = 1
  }
  
  final case class Crystal(
      base: netmsg.game.WObjectStats.Base
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Crystal] with com.trueaccord.lenses.Updatable[Crystal] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Crystal = {
        var __base = this.base
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Crystal(
            base = __base
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Crystal = copy(base = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
        }
      }
      def companion = netmsg.game.WObjectStats.Crystal
  }
  
  object Crystal extends com.trueaccord.scalapb.GeneratedMessageCompanion[Crystal]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Crystal]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Crystal = netmsg.game.WObjectStats.Crystal(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Crystal", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Crystal"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Crystal(
      base = netmsg.game.WObjectStats.Base.defaultInstance
    )
    implicit class CrystalLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Crystal]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Crystal](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
    }
    final val BASE_FIELD_NUMBER = 1
  }
  
  final case class Brush(
      base: netmsg.game.WObjectStats.Base
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Brush] with com.trueaccord.lenses.Updatable[Brush] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Brush = {
        var __base = this.base
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Brush(
            base = __base
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Brush = copy(base = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
        }
      }
      def companion = netmsg.game.WObjectStats.Brush
  }
  
  object Brush extends com.trueaccord.scalapb.GeneratedMessageCompanion[Brush]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Brush]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Brush = netmsg.game.WObjectStats.Brush(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Brush", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Brush"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Brush(
      base = netmsg.game.WObjectStats.Base.defaultInstance
    )
    implicit class BrushLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Brush]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Brush](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
    }
    final val BASE_FIELD_NUMBER = 1
  }
  
  final case class WarpGate(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      sized: netmsg.game.WObjectStats.SizedObj,
      givingActions: netmsg.game.WObjectStats.GivingActions,
      givingPopulation: netmsg.game.WObjectStats.GivingPopulation,
      specialAction: netmsg.game.WObjectStats.SpecialAction
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[WarpGate] with com.trueaccord.lenses.Updatable[WarpGate] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(sized.serializedSize) + sized.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(givingActions.serializedSize) + givingActions.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(givingPopulation.serializedSize) + givingPopulation.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(specialAction.serializedSize) + specialAction.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(sized.serializedSize)
        sized.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(givingActions.serializedSize)
        givingActions.writeTo(output)
        output.writeTag(5, 2)
        output.writeRawVarint32(givingPopulation.serializedSize)
        givingPopulation.writeTo(output)
        output.writeTag(6, 2)
        output.writeRawVarint32(specialAction.serializedSize)
        specialAction.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.WarpGate = {
        var __base = this.base
        var __owned = this.owned
        var __sized = this.sized
        var __givingActions = this.givingActions
        var __givingPopulation = this.givingPopulation
        var __specialAction = this.specialAction
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __sized = com.trueaccord.scalapb.LiteParser.readMessage(__input, __sized)
            case 34 =>
              __givingActions = com.trueaccord.scalapb.LiteParser.readMessage(__input, __givingActions)
            case 42 =>
              __givingPopulation = com.trueaccord.scalapb.LiteParser.readMessage(__input, __givingPopulation)
            case 50 =>
              __specialAction = com.trueaccord.scalapb.LiteParser.readMessage(__input, __specialAction)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.WarpGate(
            base = __base,
            owned = __owned,
            sized = __sized,
            givingActions = __givingActions,
            givingPopulation = __givingPopulation,
            specialAction = __specialAction
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): WarpGate = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): WarpGate = copy(owned = __v)
      def withSized(__v: netmsg.game.WObjectStats.SizedObj): WarpGate = copy(sized = __v)
      def withGivingActions(__v: netmsg.game.WObjectStats.GivingActions): WarpGate = copy(givingActions = __v)
      def withGivingPopulation(__v: netmsg.game.WObjectStats.GivingPopulation): WarpGate = copy(givingPopulation = __v)
      def withSpecialAction(__v: netmsg.game.WObjectStats.SpecialAction): WarpGate = copy(specialAction = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => sized
          case 4 => givingActions
          case 5 => givingPopulation
          case 6 => specialAction
        }
      }
      def companion = netmsg.game.WObjectStats.WarpGate
  }
  
  object WarpGate extends com.trueaccord.scalapb.GeneratedMessageCompanion[WarpGate]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[WarpGate]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.WarpGate = netmsg.game.WObjectStats.WarpGate(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      sized = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.SizedObj],
      givingActions = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.GivingActions],
      givingPopulation = fieldsMap(5).asInstanceOf[netmsg.game.WObjectStats.GivingPopulation],
      specialAction = fieldsMap(6).asInstanceOf[netmsg.game.WObjectStats.SpecialAction]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("WarpGate", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.WarpGate"))
    lazy val defaultInstance = netmsg.game.WObjectStats.WarpGate(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      sized = netmsg.game.WObjectStats.SizedObj.defaultInstance,
      givingActions = netmsg.game.WObjectStats.GivingActions.defaultInstance,
      givingPopulation = netmsg.game.WObjectStats.GivingPopulation.defaultInstance,
      specialAction = netmsg.game.WObjectStats.SpecialAction.defaultInstance
    )
    implicit class WarpGateLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, WarpGate]) extends com.trueaccord.lenses.ObjectLens[UpperPB, WarpGate](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def sized: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SizedObj] = field(_.sized)((c_, f_) => c_.copy(sized = f_))
      def givingActions: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.GivingActions] = field(_.givingActions)((c_, f_) => c_.copy(givingActions = f_))
      def givingPopulation: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.GivingPopulation] = field(_.givingPopulation)((c_, f_) => c_.copy(givingPopulation = f_))
      def specialAction: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SpecialAction] = field(_.specialAction)((c_, f_) => c_.copy(specialAction = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val SIZED_FIELD_NUMBER = 3
    final val GIVING_ACTIONS_FIELD_NUMBER = 4
    final val GIVING_POPULATION_FIELD_NUMBER = 5
    final val SPECIAL_ACTION_FIELD_NUMBER = 6
  }
  
  final case class Extractor(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      specialAction: netmsg.game.WObjectStats.SpecialAction,
      warpable: netmsg.game.WObjectStats.Warpable,
      specialExtractsFixed: Int,
      specialExtractsPercentage: netmsg.base.Rational
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Extractor] with com.trueaccord.lenses.Updatable[Extractor] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(specialAction.serializedSize) + specialAction.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(5, specialExtractsFixed)
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(specialExtractsPercentage.serializedSize) + specialExtractsPercentage.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(specialAction.serializedSize)
        specialAction.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
        output.writeUInt32(5, specialExtractsFixed)
        output.writeTag(6, 2)
        output.writeRawVarint32(specialExtractsPercentage.serializedSize)
        specialExtractsPercentage.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Extractor = {
        var __base = this.base
        var __owned = this.owned
        var __specialAction = this.specialAction
        var __warpable = this.warpable
        var __specialExtractsFixed = this.specialExtractsFixed
        var __specialExtractsPercentage = this.specialExtractsPercentage
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __specialAction = com.trueaccord.scalapb.LiteParser.readMessage(__input, __specialAction)
            case 34 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case 40 =>
              __specialExtractsFixed = __input.readUInt32()
            case 50 =>
              __specialExtractsPercentage = com.trueaccord.scalapb.LiteParser.readMessage(__input, __specialExtractsPercentage)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Extractor(
            base = __base,
            owned = __owned,
            specialAction = __specialAction,
            warpable = __warpable,
            specialExtractsFixed = __specialExtractsFixed,
            specialExtractsPercentage = __specialExtractsPercentage
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Extractor = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): Extractor = copy(owned = __v)
      def withSpecialAction(__v: netmsg.game.WObjectStats.SpecialAction): Extractor = copy(specialAction = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): Extractor = copy(warpable = __v)
      def withSpecialExtractsFixed(__v: Int): Extractor = copy(specialExtractsFixed = __v)
      def withSpecialExtractsPercentage(__v: netmsg.base.Rational): Extractor = copy(specialExtractsPercentage = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => specialAction
          case 4 => warpable
          case 5 => specialExtractsFixed
          case 6 => specialExtractsPercentage
        }
      }
      def companion = netmsg.game.WObjectStats.Extractor
  }
  
  object Extractor extends com.trueaccord.scalapb.GeneratedMessageCompanion[Extractor]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Extractor]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Extractor = netmsg.game.WObjectStats.Extractor(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      specialAction = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.SpecialAction],
      warpable = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Warpable],
      specialExtractsFixed = fieldsMap(5).asInstanceOf[Int],
      specialExtractsPercentage = fieldsMap(6).asInstanceOf[netmsg.base.Rational]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Extractor", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Extractor"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Extractor(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      specialAction = netmsg.game.WObjectStats.SpecialAction.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance,
      specialExtractsFixed = 0,
      specialExtractsPercentage = netmsg.base.Rational.defaultInstance
    )
    implicit class ExtractorLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Extractor]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Extractor](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def specialAction: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SpecialAction] = field(_.specialAction)((c_, f_) => c_.copy(specialAction = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
      def specialExtractsFixed: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.specialExtractsFixed)((c_, f_) => c_.copy(specialExtractsFixed = f_))
      def specialExtractsPercentage: com.trueaccord.lenses.Lens[UpperPB, netmsg.base.Rational] = field(_.specialExtractsPercentage)((c_, f_) => c_.copy(specialExtractsPercentage = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val SPECIAL_ACTION_FIELD_NUMBER = 3
    final val WARPABLE_FIELD_NUMBER = 4
    final val SPECIAL_EXTRACTS_FIXED_FIELD_NUMBER = 5
    final val SPECIAL_EXTRACTS_PERCENTAGE_FIELD_NUMBER = 6
  }
  
  final case class PopulationTower(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      warpable: netmsg.game.WObjectStats.Warpable,
      givingPopulation: netmsg.game.WObjectStats.GivingPopulation
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[PopulationTower] with com.trueaccord.lenses.Updatable[PopulationTower] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(givingPopulation.serializedSize) + givingPopulation.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(givingPopulation.serializedSize)
        givingPopulation.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.PopulationTower = {
        var __base = this.base
        var __owned = this.owned
        var __warpable = this.warpable
        var __givingPopulation = this.givingPopulation
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case 34 =>
              __givingPopulation = com.trueaccord.scalapb.LiteParser.readMessage(__input, __givingPopulation)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.PopulationTower(
            base = __base,
            owned = __owned,
            warpable = __warpable,
            givingPopulation = __givingPopulation
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): PopulationTower = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): PopulationTower = copy(owned = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): PopulationTower = copy(warpable = __v)
      def withGivingPopulation(__v: netmsg.game.WObjectStats.GivingPopulation): PopulationTower = copy(givingPopulation = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => warpable
          case 4 => givingPopulation
        }
      }
      def companion = netmsg.game.WObjectStats.PopulationTower
  }
  
  object PopulationTower extends com.trueaccord.scalapb.GeneratedMessageCompanion[PopulationTower]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[PopulationTower]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.PopulationTower = netmsg.game.WObjectStats.PopulationTower(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      warpable = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Warpable],
      givingPopulation = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.GivingPopulation]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("PopulationTower", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.PopulationTower"))
    lazy val defaultInstance = netmsg.game.WObjectStats.PopulationTower(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance,
      givingPopulation = netmsg.game.WObjectStats.GivingPopulation.defaultInstance
    )
    implicit class PopulationTowerLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, PopulationTower]) extends com.trueaccord.lenses.ObjectLens[UpperPB, PopulationTower](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
      def givingPopulation: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.GivingPopulation] = field(_.givingPopulation)((c_, f_) => c_.copy(givingPopulation = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val WARPABLE_FIELD_NUMBER = 3
    final val GIVING_POPULATION_FIELD_NUMBER = 4
  }
  
  final case class ActionTower(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      warpable: netmsg.game.WObjectStats.Warpable,
      givingActions: netmsg.game.WObjectStats.GivingActions
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[ActionTower] with com.trueaccord.lenses.Updatable[ActionTower] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(givingActions.serializedSize) + givingActions.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(givingActions.serializedSize)
        givingActions.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.ActionTower = {
        var __base = this.base
        var __owned = this.owned
        var __warpable = this.warpable
        var __givingActions = this.givingActions
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case 34 =>
              __givingActions = com.trueaccord.scalapb.LiteParser.readMessage(__input, __givingActions)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.ActionTower(
            base = __base,
            owned = __owned,
            warpable = __warpable,
            givingActions = __givingActions
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): ActionTower = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): ActionTower = copy(owned = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): ActionTower = copy(warpable = __v)
      def withGivingActions(__v: netmsg.game.WObjectStats.GivingActions): ActionTower = copy(givingActions = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => warpable
          case 4 => givingActions
        }
      }
      def companion = netmsg.game.WObjectStats.ActionTower
  }
  
  object ActionTower extends com.trueaccord.scalapb.GeneratedMessageCompanion[ActionTower]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[ActionTower]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.ActionTower = netmsg.game.WObjectStats.ActionTower(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      warpable = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Warpable],
      givingActions = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.GivingActions]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("ActionTower", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.ActionTower"))
    lazy val defaultInstance = netmsg.game.WObjectStats.ActionTower(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance,
      givingActions = netmsg.game.WObjectStats.GivingActions.defaultInstance
    )
    implicit class ActionTowerLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, ActionTower]) extends com.trueaccord.lenses.ObjectLens[UpperPB, ActionTower](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
      def givingActions: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.GivingActions] = field(_.givingActions)((c_, f_) => c_.copy(givingActions = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val WARPABLE_FIELD_NUMBER = 3
    final val GIVING_ACTIONS_FIELD_NUMBER = 4
  }
  
  final case class WarpLinker(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      warpable: netmsg.game.WObjectStats.Warpable
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[WarpLinker] with com.trueaccord.lenses.Updatable[WarpLinker] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.WarpLinker = {
        var __base = this.base
        var __owned = this.owned
        var __warpable = this.warpable
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.WarpLinker(
            base = __base,
            owned = __owned,
            warpable = __warpable
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): WarpLinker = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): WarpLinker = copy(owned = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): WarpLinker = copy(warpable = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => warpable
        }
      }
      def companion = netmsg.game.WObjectStats.WarpLinker
  }
  
  object WarpLinker extends com.trueaccord.scalapb.GeneratedMessageCompanion[WarpLinker]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[WarpLinker]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.WarpLinker = netmsg.game.WObjectStats.WarpLinker(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      warpable = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Warpable]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("WarpLinker", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.WarpLinker"))
    lazy val defaultInstance = netmsg.game.WObjectStats.WarpLinker(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance
    )
    implicit class WarpLinkerLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, WarpLinker]) extends com.trueaccord.lenses.ObjectLens[UpperPB, WarpLinker](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val WARPABLE_FIELD_NUMBER = 3
  }
  
  final case class Spawner(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      sized: netmsg.game.WObjectStats.SizedObj
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Spawner] with com.trueaccord.lenses.Updatable[Spawner] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(sized.serializedSize) + sized.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(sized.serializedSize)
        sized.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Spawner = {
        var __base = this.base
        var __owned = this.owned
        var __sized = this.sized
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __sized = com.trueaccord.scalapb.LiteParser.readMessage(__input, __sized)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Spawner(
            base = __base,
            owned = __owned,
            sized = __sized
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Spawner = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): Spawner = copy(owned = __v)
      def withSized(__v: netmsg.game.WObjectStats.SizedObj): Spawner = copy(sized = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => sized
        }
      }
      def companion = netmsg.game.WObjectStats.Spawner
  }
  
  object Spawner extends com.trueaccord.scalapb.GeneratedMessageCompanion[Spawner]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Spawner]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Spawner = netmsg.game.WObjectStats.Spawner(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      sized = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.SizedObj]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Spawner", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Spawner"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Spawner(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      sized = netmsg.game.WObjectStats.SizedObj.defaultInstance
    )
    implicit class SpawnerLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Spawner]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Spawner](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def sized: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SizedObj] = field(_.sized)((c_, f_) => c_.copy(sized = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val SIZED_FIELD_NUMBER = 3
  }
  
  final case class LaserTower(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      fighter: netmsg.game.WObjectStats.Fighter,
      warpable: netmsg.game.WObjectStats.Warpable,
      specialAction: netmsg.game.WObjectStats.SpecialAction
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[LaserTower] with com.trueaccord.lenses.Updatable[LaserTower] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(fighter.serializedSize) + fighter.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(specialAction.serializedSize) + specialAction.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(fighter.serializedSize)
        fighter.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
        output.writeTag(5, 2)
        output.writeRawVarint32(specialAction.serializedSize)
        specialAction.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.LaserTower = {
        var __base = this.base
        var __owned = this.owned
        var __fighter = this.fighter
        var __warpable = this.warpable
        var __specialAction = this.specialAction
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __fighter = com.trueaccord.scalapb.LiteParser.readMessage(__input, __fighter)
            case 34 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case 42 =>
              __specialAction = com.trueaccord.scalapb.LiteParser.readMessage(__input, __specialAction)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.LaserTower(
            base = __base,
            owned = __owned,
            fighter = __fighter,
            warpable = __warpable,
            specialAction = __specialAction
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): LaserTower = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): LaserTower = copy(owned = __v)
      def withFighter(__v: netmsg.game.WObjectStats.Fighter): LaserTower = copy(fighter = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): LaserTower = copy(warpable = __v)
      def withSpecialAction(__v: netmsg.game.WObjectStats.SpecialAction): LaserTower = copy(specialAction = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => fighter
          case 4 => warpable
          case 5 => specialAction
        }
      }
      def companion = netmsg.game.WObjectStats.LaserTower
  }
  
  object LaserTower extends com.trueaccord.scalapb.GeneratedMessageCompanion[LaserTower]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[LaserTower]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.LaserTower = netmsg.game.WObjectStats.LaserTower(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      fighter = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Fighter],
      warpable = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Warpable],
      specialAction = fieldsMap(5).asInstanceOf[netmsg.game.WObjectStats.SpecialAction]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("LaserTower", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.LaserTower"))
    lazy val defaultInstance = netmsg.game.WObjectStats.LaserTower(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      fighter = netmsg.game.WObjectStats.Fighter.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance,
      specialAction = netmsg.game.WObjectStats.SpecialAction.defaultInstance
    )
    implicit class LaserTowerLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, LaserTower]) extends com.trueaccord.lenses.ObjectLens[UpperPB, LaserTower](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def fighter: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Fighter] = field(_.fighter)((c_, f_) => c_.copy(fighter = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
      def specialAction: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SpecialAction] = field(_.specialAction)((c_, f_) => c_.copy(specialAction = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val FIGHTER_FIELD_NUMBER = 3
    final val WARPABLE_FIELD_NUMBER = 4
    final val SPECIAL_ACTION_FIELD_NUMBER = 5
  }
  
  final case class Corvette(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      fighter: netmsg.game.WObjectStats.Fighter,
      movable: netmsg.game.WObjectStats.Movable,
      specialAction: netmsg.game.WObjectStats.SpecialAction,
      warpable: netmsg.game.WObjectStats.Warpable,
      specialMovementAdded: Int
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Corvette] with com.trueaccord.lenses.Updatable[Corvette] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(fighter.serializedSize) + fighter.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(movable.serializedSize) + movable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(specialAction.serializedSize) + specialAction.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(10, specialMovementAdded)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(fighter.serializedSize)
        fighter.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(movable.serializedSize)
        movable.writeTo(output)
        output.writeTag(5, 2)
        output.writeRawVarint32(specialAction.serializedSize)
        specialAction.writeTo(output)
        output.writeTag(6, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
        output.writeUInt32(10, specialMovementAdded)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Corvette = {
        var __base = this.base
        var __owned = this.owned
        var __fighter = this.fighter
        var __movable = this.movable
        var __specialAction = this.specialAction
        var __warpable = this.warpable
        var __specialMovementAdded = this.specialMovementAdded
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __fighter = com.trueaccord.scalapb.LiteParser.readMessage(__input, __fighter)
            case 34 =>
              __movable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __movable)
            case 42 =>
              __specialAction = com.trueaccord.scalapb.LiteParser.readMessage(__input, __specialAction)
            case 50 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case 80 =>
              __specialMovementAdded = __input.readUInt32()
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Corvette(
            base = __base,
            owned = __owned,
            fighter = __fighter,
            movable = __movable,
            specialAction = __specialAction,
            warpable = __warpable,
            specialMovementAdded = __specialMovementAdded
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Corvette = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): Corvette = copy(owned = __v)
      def withFighter(__v: netmsg.game.WObjectStats.Fighter): Corvette = copy(fighter = __v)
      def withMovable(__v: netmsg.game.WObjectStats.Movable): Corvette = copy(movable = __v)
      def withSpecialAction(__v: netmsg.game.WObjectStats.SpecialAction): Corvette = copy(specialAction = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): Corvette = copy(warpable = __v)
      def withSpecialMovementAdded(__v: Int): Corvette = copy(specialMovementAdded = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => fighter
          case 4 => movable
          case 5 => specialAction
          case 6 => warpable
          case 10 => specialMovementAdded
        }
      }
      def companion = netmsg.game.WObjectStats.Corvette
  }
  
  object Corvette extends com.trueaccord.scalapb.GeneratedMessageCompanion[Corvette]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Corvette]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Corvette = netmsg.game.WObjectStats.Corvette(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      fighter = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Fighter],
      movable = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Movable],
      specialAction = fieldsMap(5).asInstanceOf[netmsg.game.WObjectStats.SpecialAction],
      warpable = fieldsMap(6).asInstanceOf[netmsg.game.WObjectStats.Warpable],
      specialMovementAdded = fieldsMap(10).asInstanceOf[Int]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Corvette", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Corvette"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Corvette(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      fighter = netmsg.game.WObjectStats.Fighter.defaultInstance,
      movable = netmsg.game.WObjectStats.Movable.defaultInstance,
      specialAction = netmsg.game.WObjectStats.SpecialAction.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance,
      specialMovementAdded = 0
    )
    implicit class CorvetteLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Corvette]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Corvette](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def fighter: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Fighter] = field(_.fighter)((c_, f_) => c_.copy(fighter = f_))
      def movable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Movable] = field(_.movable)((c_, f_) => c_.copy(movable = f_))
      def specialAction: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SpecialAction] = field(_.specialAction)((c_, f_) => c_.copy(specialAction = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
      def specialMovementAdded: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.specialMovementAdded)((c_, f_) => c_.copy(specialMovementAdded = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val FIGHTER_FIELD_NUMBER = 3
    final val MOVABLE_FIELD_NUMBER = 4
    final val SPECIAL_ACTION_FIELD_NUMBER = 5
    final val WARPABLE_FIELD_NUMBER = 6
    final val SPECIAL_MOVEMENT_ADDED_FIELD_NUMBER = 10
  }
  
  final case class WarpPrism(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      movable: netmsg.game.WObjectStats.Movable,
      specialAction: netmsg.game.WObjectStats.SpecialAction,
      warpable: netmsg.game.WObjectStats.Warpable
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[WarpPrism] with com.trueaccord.lenses.Updatable[WarpPrism] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(movable.serializedSize) + movable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(specialAction.serializedSize) + specialAction.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(movable.serializedSize)
        movable.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(specialAction.serializedSize)
        specialAction.writeTo(output)
        output.writeTag(5, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.WarpPrism = {
        var __base = this.base
        var __owned = this.owned
        var __movable = this.movable
        var __specialAction = this.specialAction
        var __warpable = this.warpable
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __movable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __movable)
            case 34 =>
              __specialAction = com.trueaccord.scalapb.LiteParser.readMessage(__input, __specialAction)
            case 42 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.WarpPrism(
            base = __base,
            owned = __owned,
            movable = __movable,
            specialAction = __specialAction,
            warpable = __warpable
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): WarpPrism = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): WarpPrism = copy(owned = __v)
      def withMovable(__v: netmsg.game.WObjectStats.Movable): WarpPrism = copy(movable = __v)
      def withSpecialAction(__v: netmsg.game.WObjectStats.SpecialAction): WarpPrism = copy(specialAction = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): WarpPrism = copy(warpable = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => movable
          case 4 => specialAction
          case 5 => warpable
        }
      }
      def companion = netmsg.game.WObjectStats.WarpPrism
  }
  
  object WarpPrism extends com.trueaccord.scalapb.GeneratedMessageCompanion[WarpPrism]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[WarpPrism]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.WarpPrism = netmsg.game.WObjectStats.WarpPrism(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      movable = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Movable],
      specialAction = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.SpecialAction],
      warpable = fieldsMap(5).asInstanceOf[netmsg.game.WObjectStats.Warpable]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("WarpPrism", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.WarpPrism"))
    lazy val defaultInstance = netmsg.game.WObjectStats.WarpPrism(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      movable = netmsg.game.WObjectStats.Movable.defaultInstance,
      specialAction = netmsg.game.WObjectStats.SpecialAction.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance
    )
    implicit class WarpPrismLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, WarpPrism]) extends com.trueaccord.lenses.ObjectLens[UpperPB, WarpPrism](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def movable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Movable] = field(_.movable)((c_, f_) => c_.copy(movable = f_))
      def specialAction: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SpecialAction] = field(_.specialAction)((c_, f_) => c_.copy(specialAction = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val MOVABLE_FIELD_NUMBER = 3
    final val SPECIAL_ACTION_FIELD_NUMBER = 4
    final val WARPABLE_FIELD_NUMBER = 5
  }
  
  final case class Drone(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      movable: netmsg.game.WObjectStats.Movable,
      warpable: netmsg.game.WObjectStats.Warpable
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Drone] with com.trueaccord.lenses.Updatable[Drone] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(movable.serializedSize) + movable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(movable.serializedSize)
        movable.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Drone = {
        var __base = this.base
        var __owned = this.owned
        var __movable = this.movable
        var __warpable = this.warpable
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __movable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __movable)
            case 34 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Drone(
            base = __base,
            owned = __owned,
            movable = __movable,
            warpable = __warpable
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Drone = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): Drone = copy(owned = __v)
      def withMovable(__v: netmsg.game.WObjectStats.Movable): Drone = copy(movable = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): Drone = copy(warpable = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => movable
          case 4 => warpable
        }
      }
      def companion = netmsg.game.WObjectStats.Drone
  }
  
  object Drone extends com.trueaccord.scalapb.GeneratedMessageCompanion[Drone]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Drone]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Drone = netmsg.game.WObjectStats.Drone(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      movable = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Movable],
      warpable = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Warpable]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Drone", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Drone"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Drone(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      movable = netmsg.game.WObjectStats.Movable.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance
    )
    implicit class DroneLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Drone]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Drone](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def movable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Movable] = field(_.movable)((c_, f_) => c_.copy(movable = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val MOVABLE_FIELD_NUMBER = 3
    final val WARPABLE_FIELD_NUMBER = 4
  }
  
  final case class Wasp(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      fighter: netmsg.game.WObjectStats.Fighter,
      movable: netmsg.game.WObjectStats.Movable,
      warpable: netmsg.game.WObjectStats.Warpable
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Wasp] with com.trueaccord.lenses.Updatable[Wasp] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(fighter.serializedSize) + fighter.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(movable.serializedSize) + movable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(fighter.serializedSize)
        fighter.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(movable.serializedSize)
        movable.writeTo(output)
        output.writeTag(5, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Wasp = {
        var __base = this.base
        var __owned = this.owned
        var __fighter = this.fighter
        var __movable = this.movable
        var __warpable = this.warpable
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __fighter = com.trueaccord.scalapb.LiteParser.readMessage(__input, __fighter)
            case 34 =>
              __movable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __movable)
            case 42 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Wasp(
            base = __base,
            owned = __owned,
            fighter = __fighter,
            movable = __movable,
            warpable = __warpable
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Wasp = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): Wasp = copy(owned = __v)
      def withFighter(__v: netmsg.game.WObjectStats.Fighter): Wasp = copy(fighter = __v)
      def withMovable(__v: netmsg.game.WObjectStats.Movable): Wasp = copy(movable = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): Wasp = copy(warpable = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => fighter
          case 4 => movable
          case 5 => warpable
        }
      }
      def companion = netmsg.game.WObjectStats.Wasp
  }
  
  object Wasp extends com.trueaccord.scalapb.GeneratedMessageCompanion[Wasp]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Wasp]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Wasp = netmsg.game.WObjectStats.Wasp(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      fighter = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Fighter],
      movable = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Movable],
      warpable = fieldsMap(5).asInstanceOf[netmsg.game.WObjectStats.Warpable]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Wasp", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Wasp"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Wasp(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      fighter = netmsg.game.WObjectStats.Fighter.defaultInstance,
      movable = netmsg.game.WObjectStats.Movable.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance
    )
    implicit class WaspLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Wasp]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Wasp](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def fighter: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Fighter] = field(_.fighter)((c_, f_) => c_.copy(fighter = f_))
      def movable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Movable] = field(_.movable)((c_, f_) => c_.copy(movable = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val FIGHTER_FIELD_NUMBER = 3
    final val MOVABLE_FIELD_NUMBER = 4
    final val WARPABLE_FIELD_NUMBER = 5
  }
  
  final case class Scout(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      movable: netmsg.game.WObjectStats.Movable,
      warpable: netmsg.game.WObjectStats.Warpable
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Scout] with com.trueaccord.lenses.Updatable[Scout] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(movable.serializedSize) + movable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(movable.serializedSize)
        movable.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Scout = {
        var __base = this.base
        var __owned = this.owned
        var __movable = this.movable
        var __warpable = this.warpable
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __movable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __movable)
            case 34 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Scout(
            base = __base,
            owned = __owned,
            movable = __movable,
            warpable = __warpable
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Scout = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): Scout = copy(owned = __v)
      def withMovable(__v: netmsg.game.WObjectStats.Movable): Scout = copy(movable = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): Scout = copy(warpable = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => movable
          case 4 => warpable
        }
      }
      def companion = netmsg.game.WObjectStats.Scout
  }
  
  object Scout extends com.trueaccord.scalapb.GeneratedMessageCompanion[Scout]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Scout]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Scout = netmsg.game.WObjectStats.Scout(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      movable = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Movable],
      warpable = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Warpable]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Scout", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Scout"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Scout(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      movable = netmsg.game.WObjectStats.Movable.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance
    )
    implicit class ScoutLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Scout]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Scout](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def movable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Movable] = field(_.movable)((c_, f_) => c_.copy(movable = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val MOVABLE_FIELD_NUMBER = 3
    final val WARPABLE_FIELD_NUMBER = 4
  }
  
  final case class RayShip(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      warpable: netmsg.game.WObjectStats.Warpable,
      fighter: netmsg.game.WObjectStats.Fighter,
      movable: netmsg.game.WObjectStats.Movable
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[RayShip] with com.trueaccord.lenses.Updatable[RayShip] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(fighter.serializedSize) + fighter.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(movable.serializedSize) + movable.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
        output.writeTag(5, 2)
        output.writeRawVarint32(fighter.serializedSize)
        fighter.writeTo(output)
        output.writeTag(6, 2)
        output.writeRawVarint32(movable.serializedSize)
        movable.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.RayShip = {
        var __base = this.base
        var __owned = this.owned
        var __warpable = this.warpable
        var __fighter = this.fighter
        var __movable = this.movable
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case 42 =>
              __fighter = com.trueaccord.scalapb.LiteParser.readMessage(__input, __fighter)
            case 50 =>
              __movable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __movable)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.RayShip(
            base = __base,
            owned = __owned,
            warpable = __warpable,
            fighter = __fighter,
            movable = __movable
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): RayShip = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): RayShip = copy(owned = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): RayShip = copy(warpable = __v)
      def withFighter(__v: netmsg.game.WObjectStats.Fighter): RayShip = copy(fighter = __v)
      def withMovable(__v: netmsg.game.WObjectStats.Movable): RayShip = copy(movable = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => warpable
          case 5 => fighter
          case 6 => movable
        }
      }
      def companion = netmsg.game.WObjectStats.RayShip
  }
  
  object RayShip extends com.trueaccord.scalapb.GeneratedMessageCompanion[RayShip]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[RayShip]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.RayShip = netmsg.game.WObjectStats.RayShip(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      warpable = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Warpable],
      fighter = fieldsMap(5).asInstanceOf[netmsg.game.WObjectStats.Fighter],
      movable = fieldsMap(6).asInstanceOf[netmsg.game.WObjectStats.Movable]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("RayShip", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.RayShip"))
    lazy val defaultInstance = netmsg.game.WObjectStats.RayShip(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance,
      fighter = netmsg.game.WObjectStats.Fighter.defaultInstance,
      movable = netmsg.game.WObjectStats.Movable.defaultInstance
    )
    implicit class RayShipLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, RayShip]) extends com.trueaccord.lenses.ObjectLens[UpperPB, RayShip](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
      def fighter: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Fighter] = field(_.fighter)((c_, f_) => c_.copy(fighter = f_))
      def movable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Movable] = field(_.movable)((c_, f_) => c_.copy(movable = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val WARPABLE_FIELD_NUMBER = 3
    final val FIGHTER_FIELD_NUMBER = 5
    final val MOVABLE_FIELD_NUMBER = 6
  }
  
  final case class RocketFrigate(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      fighter: netmsg.game.WObjectStats.Fighter,
      movable: netmsg.game.WObjectStats.Movable,
      warpable: netmsg.game.WObjectStats.Warpable,
      specialAction: netmsg.game.WObjectStats.SpecialAction
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[RocketFrigate] with com.trueaccord.lenses.Updatable[RocketFrigate] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(fighter.serializedSize) + fighter.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(movable.serializedSize) + movable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(specialAction.serializedSize) + specialAction.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(fighter.serializedSize)
        fighter.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(movable.serializedSize)
        movable.writeTo(output)
        output.writeTag(5, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
        output.writeTag(6, 2)
        output.writeRawVarint32(specialAction.serializedSize)
        specialAction.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.RocketFrigate = {
        var __base = this.base
        var __owned = this.owned
        var __fighter = this.fighter
        var __movable = this.movable
        var __warpable = this.warpable
        var __specialAction = this.specialAction
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __fighter = com.trueaccord.scalapb.LiteParser.readMessage(__input, __fighter)
            case 34 =>
              __movable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __movable)
            case 42 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case 50 =>
              __specialAction = com.trueaccord.scalapb.LiteParser.readMessage(__input, __specialAction)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.RocketFrigate(
            base = __base,
            owned = __owned,
            fighter = __fighter,
            movable = __movable,
            warpable = __warpable,
            specialAction = __specialAction
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): RocketFrigate = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): RocketFrigate = copy(owned = __v)
      def withFighter(__v: netmsg.game.WObjectStats.Fighter): RocketFrigate = copy(fighter = __v)
      def withMovable(__v: netmsg.game.WObjectStats.Movable): RocketFrigate = copy(movable = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): RocketFrigate = copy(warpable = __v)
      def withSpecialAction(__v: netmsg.game.WObjectStats.SpecialAction): RocketFrigate = copy(specialAction = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => fighter
          case 4 => movable
          case 5 => warpable
          case 6 => specialAction
        }
      }
      def companion = netmsg.game.WObjectStats.RocketFrigate
  }
  
  object RocketFrigate extends com.trueaccord.scalapb.GeneratedMessageCompanion[RocketFrigate]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[RocketFrigate]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.RocketFrigate = netmsg.game.WObjectStats.RocketFrigate(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      fighter = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Fighter],
      movable = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Movable],
      warpable = fieldsMap(5).asInstanceOf[netmsg.game.WObjectStats.Warpable],
      specialAction = fieldsMap(6).asInstanceOf[netmsg.game.WObjectStats.SpecialAction]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("RocketFrigate", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.RocketFrigate"))
    lazy val defaultInstance = netmsg.game.WObjectStats.RocketFrigate(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      fighter = netmsg.game.WObjectStats.Fighter.defaultInstance,
      movable = netmsg.game.WObjectStats.Movable.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance,
      specialAction = netmsg.game.WObjectStats.SpecialAction.defaultInstance
    )
    implicit class RocketFrigateLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, RocketFrigate]) extends com.trueaccord.lenses.ObjectLens[UpperPB, RocketFrigate](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def fighter: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Fighter] = field(_.fighter)((c_, f_) => c_.copy(fighter = f_))
      def movable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Movable] = field(_.movable)((c_, f_) => c_.copy(movable = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
      def specialAction: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SpecialAction] = field(_.specialAction)((c_, f_) => c_.copy(specialAction = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val FIGHTER_FIELD_NUMBER = 3
    final val MOVABLE_FIELD_NUMBER = 4
    final val WARPABLE_FIELD_NUMBER = 5
    final val SPECIAL_ACTION_FIELD_NUMBER = 6
  }
  
  final case class RocketFrigateDeployed(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      fighter: netmsg.game.WObjectStats.Fighter,
      specialAction: netmsg.game.WObjectStats.SpecialAction
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[RocketFrigateDeployed] with com.trueaccord.lenses.Updatable[RocketFrigateDeployed] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(fighter.serializedSize) + fighter.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(specialAction.serializedSize) + specialAction.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(fighter.serializedSize)
        fighter.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(specialAction.serializedSize)
        specialAction.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.RocketFrigateDeployed = {
        var __base = this.base
        var __owned = this.owned
        var __fighter = this.fighter
        var __specialAction = this.specialAction
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __fighter = com.trueaccord.scalapb.LiteParser.readMessage(__input, __fighter)
            case 34 =>
              __specialAction = com.trueaccord.scalapb.LiteParser.readMessage(__input, __specialAction)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.RocketFrigateDeployed(
            base = __base,
            owned = __owned,
            fighter = __fighter,
            specialAction = __specialAction
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): RocketFrigateDeployed = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): RocketFrigateDeployed = copy(owned = __v)
      def withFighter(__v: netmsg.game.WObjectStats.Fighter): RocketFrigateDeployed = copy(fighter = __v)
      def withSpecialAction(__v: netmsg.game.WObjectStats.SpecialAction): RocketFrigateDeployed = copy(specialAction = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => fighter
          case 4 => specialAction
        }
      }
      def companion = netmsg.game.WObjectStats.RocketFrigateDeployed
  }
  
  object RocketFrigateDeployed extends com.trueaccord.scalapb.GeneratedMessageCompanion[RocketFrigateDeployed]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[RocketFrigateDeployed]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.RocketFrigateDeployed = netmsg.game.WObjectStats.RocketFrigateDeployed(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      fighter = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Fighter],
      specialAction = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.SpecialAction]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("RocketFrigateDeployed", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.RocketFrigateDeployed"))
    lazy val defaultInstance = netmsg.game.WObjectStats.RocketFrigateDeployed(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      fighter = netmsg.game.WObjectStats.Fighter.defaultInstance,
      specialAction = netmsg.game.WObjectStats.SpecialAction.defaultInstance
    )
    implicit class RocketFrigateDeployedLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, RocketFrigateDeployed]) extends com.trueaccord.lenses.ObjectLens[UpperPB, RocketFrigateDeployed](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def fighter: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Fighter] = field(_.fighter)((c_, f_) => c_.copy(fighter = f_))
      def specialAction: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SpecialAction] = field(_.specialAction)((c_, f_) => c_.copy(specialAction = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val FIGHTER_FIELD_NUMBER = 3
    final val SPECIAL_ACTION_FIELD_NUMBER = 4
  }
  
  final case class Gunship(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      fighter: netmsg.game.WObjectStats.Fighter,
      movable: netmsg.game.WObjectStats.Movable,
      warpable: netmsg.game.WObjectStats.Warpable
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Gunship] with com.trueaccord.lenses.Updatable[Gunship] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(fighter.serializedSize) + fighter.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(movable.serializedSize) + movable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(fighter.serializedSize)
        fighter.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(movable.serializedSize)
        movable.writeTo(output)
        output.writeTag(5, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Gunship = {
        var __base = this.base
        var __owned = this.owned
        var __fighter = this.fighter
        var __movable = this.movable
        var __warpable = this.warpable
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __fighter = com.trueaccord.scalapb.LiteParser.readMessage(__input, __fighter)
            case 34 =>
              __movable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __movable)
            case 42 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Gunship(
            base = __base,
            owned = __owned,
            fighter = __fighter,
            movable = __movable,
            warpable = __warpable
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Gunship = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): Gunship = copy(owned = __v)
      def withFighter(__v: netmsg.game.WObjectStats.Fighter): Gunship = copy(fighter = __v)
      def withMovable(__v: netmsg.game.WObjectStats.Movable): Gunship = copy(movable = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): Gunship = copy(warpable = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => fighter
          case 4 => movable
          case 5 => warpable
        }
      }
      def companion = netmsg.game.WObjectStats.Gunship
  }
  
  object Gunship extends com.trueaccord.scalapb.GeneratedMessageCompanion[Gunship]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Gunship]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Gunship = netmsg.game.WObjectStats.Gunship(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      fighter = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Fighter],
      movable = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Movable],
      warpable = fieldsMap(5).asInstanceOf[netmsg.game.WObjectStats.Warpable]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Gunship", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Gunship"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Gunship(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      fighter = netmsg.game.WObjectStats.Fighter.defaultInstance,
      movable = netmsg.game.WObjectStats.Movable.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance
    )
    implicit class GunshipLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Gunship]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Gunship](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def fighter: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Fighter] = field(_.fighter)((c_, f_) => c_.copy(fighter = f_))
      def movable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Movable] = field(_.movable)((c_, f_) => c_.copy(movable = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val FIGHTER_FIELD_NUMBER = 3
    final val MOVABLE_FIELD_NUMBER = 4
    final val WARPABLE_FIELD_NUMBER = 5
  }
  
  final case class Fortress(
      base: netmsg.game.WObjectStats.Base,
      owned: netmsg.game.WObjectStats.OwnedObj,
      fighter: netmsg.game.WObjectStats.Fighter,
      movable: netmsg.game.WObjectStats.Movable,
      warpable: netmsg.game.WObjectStats.Warpable
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Fortress] with com.trueaccord.lenses.Updatable[Fortress] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(fighter.serializedSize) + fighter.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(movable.serializedSize) + movable.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warpable.serializedSize) + warpable.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(fighter.serializedSize)
        fighter.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(movable.serializedSize)
        movable.writeTo(output)
        output.writeTag(5, 2)
        output.writeRawVarint32(warpable.serializedSize)
        warpable.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.Fortress = {
        var __base = this.base
        var __owned = this.owned
        var __fighter = this.fighter
        var __movable = this.movable
        var __warpable = this.warpable
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 26 =>
              __fighter = com.trueaccord.scalapb.LiteParser.readMessage(__input, __fighter)
            case 34 =>
              __movable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __movable)
            case 42 =>
              __warpable = com.trueaccord.scalapb.LiteParser.readMessage(__input, __warpable)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.Fortress(
            base = __base,
            owned = __owned,
            fighter = __fighter,
            movable = __movable,
            warpable = __warpable
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): Fortress = copy(base = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): Fortress = copy(owned = __v)
      def withFighter(__v: netmsg.game.WObjectStats.Fighter): Fortress = copy(fighter = __v)
      def withMovable(__v: netmsg.game.WObjectStats.Movable): Fortress = copy(movable = __v)
      def withWarpable(__v: netmsg.game.WObjectStats.Warpable): Fortress = copy(warpable = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => owned
          case 3 => fighter
          case 4 => movable
          case 5 => warpable
        }
      }
      def companion = netmsg.game.WObjectStats.Fortress
  }
  
  object Fortress extends com.trueaccord.scalapb.GeneratedMessageCompanion[Fortress]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Fortress]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.Fortress = netmsg.game.WObjectStats.Fortress(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      owned = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      fighter = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.Fighter],
      movable = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.Movable],
      warpable = fieldsMap(5).asInstanceOf[netmsg.game.WObjectStats.Warpable]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Fortress", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.Fortress"))
    lazy val defaultInstance = netmsg.game.WObjectStats.Fortress(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      fighter = netmsg.game.WObjectStats.Fighter.defaultInstance,
      movable = netmsg.game.WObjectStats.Movable.defaultInstance,
      warpable = netmsg.game.WObjectStats.Warpable.defaultInstance
    )
    implicit class FortressLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Fortress]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Fortress](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def fighter: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Fighter] = field(_.fighter)((c_, f_) => c_.copy(fighter = f_))
      def movable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Movable] = field(_.movable)((c_, f_) => c_.copy(movable = f_))
      def warpable: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Warpable] = field(_.warpable)((c_, f_) => c_.copy(warpable = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val OWNED_FIELD_NUMBER = 2
    final val FIGHTER_FIELD_NUMBER = 3
    final val MOVABLE_FIELD_NUMBER = 4
    final val WARPABLE_FIELD_NUMBER = 5
  }
  
  final case class VpTower(
      base: netmsg.game.WObjectStats.Base,
      sized: netmsg.game.WObjectStats.SizedObj,
      owned: netmsg.game.WObjectStats.OwnedObj,
      givingActions: netmsg.game.WObjectStats.GivingActions
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[VpTower] with com.trueaccord.lenses.Updatable[VpTower] {
      lazy val serializedSize: Int = {
        var __size = 0
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(base.serializedSize) + base.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(sized.serializedSize) + sized.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(owned.serializedSize) + owned.serializedSize
        __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(givingActions.serializedSize) + givingActions.serializedSize
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        output.writeTag(1, 2)
        output.writeRawVarint32(base.serializedSize)
        base.writeTo(output)
        output.writeTag(2, 2)
        output.writeRawVarint32(sized.serializedSize)
        sized.writeTo(output)
        output.writeTag(3, 2)
        output.writeRawVarint32(owned.serializedSize)
        owned.writeTo(output)
        output.writeTag(4, 2)
        output.writeRawVarint32(givingActions.serializedSize)
        givingActions.writeTo(output)
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.WObjectStats.VpTower = {
        var __base = this.base
        var __sized = this.sized
        var __owned = this.owned
        var __givingActions = this.givingActions
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __base = com.trueaccord.scalapb.LiteParser.readMessage(__input, __base)
            case 18 =>
              __sized = com.trueaccord.scalapb.LiteParser.readMessage(__input, __sized)
            case 26 =>
              __owned = com.trueaccord.scalapb.LiteParser.readMessage(__input, __owned)
            case 34 =>
              __givingActions = com.trueaccord.scalapb.LiteParser.readMessage(__input, __givingActions)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.WObjectStats.VpTower(
            base = __base,
            sized = __sized,
            owned = __owned,
            givingActions = __givingActions
        )
      }
      def withBase(__v: netmsg.game.WObjectStats.Base): VpTower = copy(base = __v)
      def withSized(__v: netmsg.game.WObjectStats.SizedObj): VpTower = copy(sized = __v)
      def withOwned(__v: netmsg.game.WObjectStats.OwnedObj): VpTower = copy(owned = __v)
      def withGivingActions(__v: netmsg.game.WObjectStats.GivingActions): VpTower = copy(givingActions = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => base
          case 2 => sized
          case 3 => owned
          case 4 => givingActions
        }
      }
      def companion = netmsg.game.WObjectStats.VpTower
  }
  
  object VpTower extends com.trueaccord.scalapb.GeneratedMessageCompanion[VpTower]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[VpTower]  = this
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.WObjectStats.VpTower = netmsg.game.WObjectStats.VpTower(
      base = fieldsMap(1).asInstanceOf[netmsg.game.WObjectStats.Base],
      sized = fieldsMap(2).asInstanceOf[netmsg.game.WObjectStats.SizedObj],
      owned = fieldsMap(3).asInstanceOf[netmsg.game.WObjectStats.OwnedObj],
      givingActions = fieldsMap(4).asInstanceOf[netmsg.game.WObjectStats.GivingActions]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("VpTower", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.WObjectStats.VpTower"))
    lazy val defaultInstance = netmsg.game.WObjectStats.VpTower(
      base = netmsg.game.WObjectStats.Base.defaultInstance,
      sized = netmsg.game.WObjectStats.SizedObj.defaultInstance,
      owned = netmsg.game.WObjectStats.OwnedObj.defaultInstance,
      givingActions = netmsg.game.WObjectStats.GivingActions.defaultInstance
    )
    implicit class VpTowerLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, VpTower]) extends com.trueaccord.lenses.ObjectLens[UpperPB, VpTower](_l) {
      def base: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.Base] = field(_.base)((c_, f_) => c_.copy(base = f_))
      def sized: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.SizedObj] = field(_.sized)((c_, f_) => c_.copy(sized = f_))
      def owned: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.OwnedObj] = field(_.owned)((c_, f_) => c_.copy(owned = f_))
      def givingActions: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjectStats.GivingActions] = field(_.givingActions)((c_, f_) => c_.copy(givingActions = f_))
    }
    final val BASE_FIELD_NUMBER = 1
    final val SIZED_FIELD_NUMBER = 2
    final val OWNED_FIELD_NUMBER = 3
    final val GIVING_ACTIONS_FIELD_NUMBER = 4
  }
  
  implicit class WObjectStatsLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, WObjectStats]) extends com.trueaccord.lenses.ObjectLens[UpperPB, WObjectStats](_l) {
  }
}
