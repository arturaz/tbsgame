// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!

package netmsg.game

import scala.collection.JavaConversions._
import com.trueaccord.scalapb.Descriptors

final case class MMovement(
    id: netmsg.game.WObjID,
    paths: Option[netmsg.game.MMovement.Paths] = None,
    positions: Option[netmsg.game.MMovement.Positions] = None
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[MMovement] with com.trueaccord.lenses.Updatable[MMovement] {
    lazy val serializedSize: Int = {
      var __size = 0
      __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(id.serializedSize) + id.serializedSize
      if (paths.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(paths.get.serializedSize) + paths.get.serializedSize }
      if (positions.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(positions.get.serializedSize) + positions.get.serializedSize }
      __size
    }
    def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
      output.writeTag(1, 2)
      output.writeRawVarint32(id.serializedSize)
      id.writeTo(output)
      paths.foreach { v => 
        output.writeTag(2, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      positions.foreach { v => 
        output.writeTag(3, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
    }
    def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.MMovement = {
      var __id = this.id
      var __paths = this.paths
      var __positions = this.positions
      var _done__ = false
      while (!_done__) {
        val _tag__ = __input.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __id = com.trueaccord.scalapb.LiteParser.readMessage(__input, __id)
          case 18 =>
            __paths = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __paths.getOrElse(netmsg.game.MMovement.Paths.defaultInstance)))
          case 26 =>
            __positions = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __positions.getOrElse(netmsg.game.MMovement.Positions.defaultInstance)))
          case tag => __input.skipField(tag)
        }
      }
      netmsg.game.MMovement(
          id = __id,
          paths = __paths,
          positions = __positions
      )
    }
    def withId(__v: netmsg.game.WObjID): MMovement = copy(id = __v)
    def getPaths: netmsg.game.MMovement.Paths = paths.getOrElse(netmsg.game.MMovement.Paths.defaultInstance)
    def clearPaths: MMovement = copy(paths = None)
    def withPaths(__v: netmsg.game.MMovement.Paths): MMovement = copy(paths = Some(__v))
    def getPositions: netmsg.game.MMovement.Positions = positions.getOrElse(netmsg.game.MMovement.Positions.defaultInstance)
    def clearPositions: MMovement = copy(positions = None)
    def withPositions(__v: netmsg.game.MMovement.Positions): MMovement = copy(positions = Some(__v))
    def getField(__field: Descriptors.FieldDescriptor): Any = {
      __field.number match {
        case 1 => id
        case 2 => paths
        case 3 => positions
      }
    }
    override def toString: String = com.google.protobuf.TextFormat.printToString(netmsg.game.MMovement.toJavaProto(this))
    def companion = netmsg.game.MMovement
}

object MMovement extends com.trueaccord.scalapb.GeneratedMessageCompanion[MMovement] with com.trueaccord.scalapb.JavaProtoSupport[MMovement, netmsg.Game.MMovement]  {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[MMovement] with com.trueaccord.scalapb.JavaProtoSupport[MMovement, netmsg.Game.MMovement]  = this
  def toJavaProto(scalaPbSource: netmsg.game.MMovement): netmsg.Game.MMovement = {
    val javaPbOut = netmsg.Game.MMovement.newBuilder
    javaPbOut.setId(netmsg.game.WObjID.toJavaProto(scalaPbSource.id))
    scalaPbSource.paths.map(netmsg.game.MMovement.Paths.toJavaProto).foreach(javaPbOut.setPaths)
    scalaPbSource.positions.map(netmsg.game.MMovement.Positions.toJavaProto).foreach(javaPbOut.setPositions)
    javaPbOut.build
  }
  def fromJavaProto(javaPbSource: netmsg.Game.MMovement): netmsg.game.MMovement = netmsg.game.MMovement(
    id = netmsg.game.WObjID.fromJavaProto(javaPbSource.getId),
    paths = if (javaPbSource.hasPaths) Some(netmsg.game.MMovement.Paths.fromJavaProto(javaPbSource.getPaths)) else None,
    positions = if (javaPbSource.hasPositions) Some(netmsg.game.MMovement.Positions.fromJavaProto(javaPbSource.getPositions)) else None
  )
  override def fromAscii(ascii: String): netmsg.game.MMovement = {
    val javaProtoBuilder = netmsg.Game.MMovement.newBuilder
    com.google.protobuf.TextFormat.merge(ascii, javaProtoBuilder)
    fromJavaProto(javaProtoBuilder.build)
  }
  def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.MMovement = netmsg.game.MMovement(
    id = fieldsMap(1).asInstanceOf[netmsg.game.WObjID],
    paths = fieldsMap.getOrElse(2, None).asInstanceOf[Option[netmsg.game.MMovement.Paths]],
    positions = fieldsMap.getOrElse(3, None).asInstanceOf[Option[netmsg.game.MMovement.Positions]]
  )
  lazy val descriptor = new Descriptors.MessageDescriptor("MMovement", this,
    None, m = Seq(netmsg.game.MMovement.Path.descriptor, netmsg.game.MMovement.Paths.descriptor, netmsg.game.MMovement.Positions.descriptor),
    e = Seq(),
    f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.MMovement"))
  lazy val defaultInstance = netmsg.game.MMovement(
    id = netmsg.game.WObjID.defaultInstance
  )
  final case class Path(
      position: Seq[netmsg.base.Vect2] = Nil
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Path] with com.trueaccord.lenses.Updatable[Path] {
      lazy val serializedSize: Int = {
        var __size = 0
        position.foreach(position => __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(position.serializedSize) + position.serializedSize)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        position.foreach { v => 
          output.writeTag(1, 2)
          output.writeRawVarint32(v.serializedSize)
          v.writeTo(output)
        }
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.MMovement.Path = {
        val __position = (scala.collection.immutable.Vector.newBuilder[netmsg.base.Vect2] ++= this.position)
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __position += com.trueaccord.scalapb.LiteParser.readMessage(__input, netmsg.base.Vect2.defaultInstance)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.MMovement.Path(
            position = __position.result()
        )
      }
      def clearPosition = copy(position = Nil)
      def addPosition(__vs: netmsg.base.Vect2*): Path = addAllPosition(__vs)
      def addAllPosition(__vs: TraversableOnce[netmsg.base.Vect2]): Path = copy(position = position ++ __vs)
      def withPosition(__v: Seq[netmsg.base.Vect2]): Path = copy(position = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => position
        }
      }
      override def toString: String = com.google.protobuf.TextFormat.printToString(netmsg.game.MMovement.Path.toJavaProto(this))
      def companion = netmsg.game.MMovement.Path
  }
  
  object Path extends com.trueaccord.scalapb.GeneratedMessageCompanion[Path] with com.trueaccord.scalapb.JavaProtoSupport[Path, netmsg.Game.MMovement.Path]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Path] with com.trueaccord.scalapb.JavaProtoSupport[Path, netmsg.Game.MMovement.Path]  = this
    def toJavaProto(scalaPbSource: netmsg.game.MMovement.Path): netmsg.Game.MMovement.Path = {
      val javaPbOut = netmsg.Game.MMovement.Path.newBuilder
      javaPbOut.addAllPosition(scalaPbSource.position.map(netmsg.base.Vect2.toJavaProto))
      javaPbOut.build
    }
    def fromJavaProto(javaPbSource: netmsg.Game.MMovement.Path): netmsg.game.MMovement.Path = netmsg.game.MMovement.Path(
      position = javaPbSource.getPositionList.map(netmsg.base.Vect2.fromJavaProto)
    )
    override def fromAscii(ascii: String): netmsg.game.MMovement.Path = {
      val javaProtoBuilder = netmsg.Game.MMovement.Path.newBuilder
      com.google.protobuf.TextFormat.merge(ascii, javaProtoBuilder)
      fromJavaProto(javaProtoBuilder.build)
    }
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.MMovement.Path = netmsg.game.MMovement.Path(
      position = fieldsMap.getOrElse(1, Nil).asInstanceOf[Seq[netmsg.base.Vect2]]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Path", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.MMovement.Path"))
    lazy val defaultInstance = netmsg.game.MMovement.Path(
    )
    implicit class PathLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Path]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Path](_l) {
      def position: com.trueaccord.lenses.Lens[UpperPB, Seq[netmsg.base.Vect2]] = field(_.position)((c_, f_) => c_.copy(position = f_))
    }
    final val POSITION_FIELD_NUMBER = 1
  }
  
  final case class Paths(
      path: Seq[netmsg.game.MMovement.Path] = Nil
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Paths] with com.trueaccord.lenses.Updatable[Paths] {
      lazy val serializedSize: Int = {
        var __size = 0
        path.foreach(path => __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(path.serializedSize) + path.serializedSize)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        path.foreach { v => 
          output.writeTag(1, 2)
          output.writeRawVarint32(v.serializedSize)
          v.writeTo(output)
        }
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.MMovement.Paths = {
        val __path = (scala.collection.immutable.Vector.newBuilder[netmsg.game.MMovement.Path] ++= this.path)
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __path += com.trueaccord.scalapb.LiteParser.readMessage(__input, netmsg.game.MMovement.Path.defaultInstance)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.MMovement.Paths(
            path = __path.result()
        )
      }
      def clearPath = copy(path = Nil)
      def addPath(__vs: netmsg.game.MMovement.Path*): Paths = addAllPath(__vs)
      def addAllPath(__vs: TraversableOnce[netmsg.game.MMovement.Path]): Paths = copy(path = path ++ __vs)
      def withPath(__v: Seq[netmsg.game.MMovement.Path]): Paths = copy(path = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => path
        }
      }
      override def toString: String = com.google.protobuf.TextFormat.printToString(netmsg.game.MMovement.Paths.toJavaProto(this))
      def companion = netmsg.game.MMovement.Paths
  }
  
  object Paths extends com.trueaccord.scalapb.GeneratedMessageCompanion[Paths] with com.trueaccord.scalapb.JavaProtoSupport[Paths, netmsg.Game.MMovement.Paths]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Paths] with com.trueaccord.scalapb.JavaProtoSupport[Paths, netmsg.Game.MMovement.Paths]  = this
    def toJavaProto(scalaPbSource: netmsg.game.MMovement.Paths): netmsg.Game.MMovement.Paths = {
      val javaPbOut = netmsg.Game.MMovement.Paths.newBuilder
      javaPbOut.addAllPath(scalaPbSource.path.map(netmsg.game.MMovement.Path.toJavaProto))
      javaPbOut.build
    }
    def fromJavaProto(javaPbSource: netmsg.Game.MMovement.Paths): netmsg.game.MMovement.Paths = netmsg.game.MMovement.Paths(
      path = javaPbSource.getPathList.map(netmsg.game.MMovement.Path.fromJavaProto)
    )
    override def fromAscii(ascii: String): netmsg.game.MMovement.Paths = {
      val javaProtoBuilder = netmsg.Game.MMovement.Paths.newBuilder
      com.google.protobuf.TextFormat.merge(ascii, javaProtoBuilder)
      fromJavaProto(javaProtoBuilder.build)
    }
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.MMovement.Paths = netmsg.game.MMovement.Paths(
      path = fieldsMap.getOrElse(1, Nil).asInstanceOf[Seq[netmsg.game.MMovement.Path]]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Paths", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.MMovement.Paths"))
    lazy val defaultInstance = netmsg.game.MMovement.Paths(
    )
    implicit class PathsLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Paths]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Paths](_l) {
      def path: com.trueaccord.lenses.Lens[UpperPB, Seq[netmsg.game.MMovement.Path]] = field(_.path)((c_, f_) => c_.copy(path = f_))
    }
    final val PATH_FIELD_NUMBER = 1
  }
  
  final case class Positions(
      position: Seq[netmsg.base.Vect2] = Nil
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Positions] with com.trueaccord.lenses.Updatable[Positions] {
      lazy val serializedSize: Int = {
        var __size = 0
        position.foreach(position => __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(position.serializedSize) + position.serializedSize)
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        position.foreach { v => 
          output.writeTag(1, 2)
          output.writeRawVarint32(v.serializedSize)
          v.writeTo(output)
        }
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.MMovement.Positions = {
        val __position = (scala.collection.immutable.Vector.newBuilder[netmsg.base.Vect2] ++= this.position)
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __position += com.trueaccord.scalapb.LiteParser.readMessage(__input, netmsg.base.Vect2.defaultInstance)
            case tag => __input.skipField(tag)
          }
        }
        netmsg.game.MMovement.Positions(
            position = __position.result()
        )
      }
      def clearPosition = copy(position = Nil)
      def addPosition(__vs: netmsg.base.Vect2*): Positions = addAllPosition(__vs)
      def addAllPosition(__vs: TraversableOnce[netmsg.base.Vect2]): Positions = copy(position = position ++ __vs)
      def withPosition(__v: Seq[netmsg.base.Vect2]): Positions = copy(position = __v)
      def getField(__field: Descriptors.FieldDescriptor): Any = {
        __field.number match {
          case 1 => position
        }
      }
      override def toString: String = com.google.protobuf.TextFormat.printToString(netmsg.game.MMovement.Positions.toJavaProto(this))
      def companion = netmsg.game.MMovement.Positions
  }
  
  object Positions extends com.trueaccord.scalapb.GeneratedMessageCompanion[Positions] with com.trueaccord.scalapb.JavaProtoSupport[Positions, netmsg.Game.MMovement.Positions]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Positions] with com.trueaccord.scalapb.JavaProtoSupport[Positions, netmsg.Game.MMovement.Positions]  = this
    def toJavaProto(scalaPbSource: netmsg.game.MMovement.Positions): netmsg.Game.MMovement.Positions = {
      val javaPbOut = netmsg.Game.MMovement.Positions.newBuilder
      javaPbOut.addAllPosition(scalaPbSource.position.map(netmsg.base.Vect2.toJavaProto))
      javaPbOut.build
    }
    def fromJavaProto(javaPbSource: netmsg.Game.MMovement.Positions): netmsg.game.MMovement.Positions = netmsg.game.MMovement.Positions(
      position = javaPbSource.getPositionList.map(netmsg.base.Vect2.fromJavaProto)
    )
    override def fromAscii(ascii: String): netmsg.game.MMovement.Positions = {
      val javaProtoBuilder = netmsg.Game.MMovement.Positions.newBuilder
      com.google.protobuf.TextFormat.merge(ascii, javaProtoBuilder)
      fromJavaProto(javaProtoBuilder.build)
    }
    def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.MMovement.Positions = netmsg.game.MMovement.Positions(
      position = fieldsMap.getOrElse(1, Nil).asInstanceOf[Seq[netmsg.base.Vect2]]
    )
    lazy val descriptor = new Descriptors.MessageDescriptor("Positions", this,
      None, m = Seq(),
      e = Seq(),
      f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.MMovement.Positions"))
    lazy val defaultInstance = netmsg.game.MMovement.Positions(
    )
    implicit class PositionsLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Positions]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Positions](_l) {
      def position: com.trueaccord.lenses.Lens[UpperPB, Seq[netmsg.base.Vect2]] = field(_.position)((c_, f_) => c_.copy(position = f_))
    }
    final val POSITION_FIELD_NUMBER = 1
  }
  
  implicit class MMovementLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, MMovement]) extends com.trueaccord.lenses.ObjectLens[UpperPB, MMovement](_l) {
    def id: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.WObjID] = field(_.id)((c_, f_) => c_.copy(id = f_))
    def paths: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MMovement.Paths] = field(_.getPaths)((c_, f_) => c_.copy(paths = Some(f_)))
    def optionalPaths: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MMovement.Paths]] = field(_.paths)((c_, f_) => c_.copy(paths = f_))
    def positions: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MMovement.Positions] = field(_.getPositions)((c_, f_) => c_.copy(positions = Some(f_)))
    def optionalPositions: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MMovement.Positions]] = field(_.positions)((c_, f_) => c_.copy(positions = f_))
  }
  final val ID_FIELD_NUMBER = 1
  final val PATHS_FIELD_NUMBER = 2
  final val POSITIONS_FIELD_NUMBER = 3
}
