// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!

package netmsg.game


import com.trueaccord.scalapb.Descriptors

final case class FromClient(
    warp: Option[netmsg.game.MWarp] = None,
    move: Option[netmsg.game.MMove] = None,
    attackPos: Option[netmsg.game.MAttackPos] = None,
    attack: Option[netmsg.game.MAttack] = None,
    special: Option[netmsg.game.MSpecial] = None,
    moveAttack: Option[netmsg.game.MMoveAttack] = None,
    leave: Option[netmsg.game.MLeave] = None,
    toggleWaitingForRoundEnd: Option[netmsg.game.MToggleWaitingForRoundEnd] = None,
    concede: Option[netmsg.game.MConcede] = None
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[FromClient] with com.trueaccord.lenses.Updatable[FromClient] {
    lazy val serializedSize: Int = {
      var __size = 0
      if (warp.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(warp.get.serializedSize) + warp.get.serializedSize }
      if (move.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(move.get.serializedSize) + move.get.serializedSize }
      if (attackPos.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(attackPos.get.serializedSize) + attackPos.get.serializedSize }
      if (attack.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(attack.get.serializedSize) + attack.get.serializedSize }
      if (special.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(special.get.serializedSize) + special.get.serializedSize }
      if (moveAttack.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(moveAttack.get.serializedSize) + moveAttack.get.serializedSize }
      if (leave.isDefined) { __size += 2 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(leave.get.serializedSize) + leave.get.serializedSize }
      if (toggleWaitingForRoundEnd.isDefined) { __size += 2 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(toggleWaitingForRoundEnd.get.serializedSize) + toggleWaitingForRoundEnd.get.serializedSize }
      if (concede.isDefined) { __size += 2 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(concede.get.serializedSize) + concede.get.serializedSize }
      __size
    }
    def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
      warp.foreach { v => 
        output.writeTag(1, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      move.foreach { v => 
        output.writeTag(2, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      attackPos.foreach { v => 
        output.writeTag(3, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      attack.foreach { v => 
        output.writeTag(4, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      special.foreach { v => 
        output.writeTag(5, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      moveAttack.foreach { v => 
        output.writeTag(6, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      leave.foreach { v => 
        output.writeTag(1001, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      toggleWaitingForRoundEnd.foreach { v => 
        output.writeTag(1002, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      concede.foreach { v => 
        output.writeTag(1003, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
    }
    def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.FromClient = {
      var __warp = this.warp
      var __move = this.move
      var __attackPos = this.attackPos
      var __attack = this.attack
      var __special = this.special
      var __moveAttack = this.moveAttack
      var __leave = this.leave
      var __toggleWaitingForRoundEnd = this.toggleWaitingForRoundEnd
      var __concede = this.concede
      var _done__ = false
      while (!_done__) {
        val _tag__ = __input.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __warp = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __warp.getOrElse(netmsg.game.MWarp.defaultInstance)))
          case 18 =>
            __move = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __move.getOrElse(netmsg.game.MMove.defaultInstance)))
          case 26 =>
            __attackPos = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __attackPos.getOrElse(netmsg.game.MAttackPos.defaultInstance)))
          case 34 =>
            __attack = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __attack.getOrElse(netmsg.game.MAttack.defaultInstance)))
          case 42 =>
            __special = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __special.getOrElse(netmsg.game.MSpecial.defaultInstance)))
          case 50 =>
            __moveAttack = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __moveAttack.getOrElse(netmsg.game.MMoveAttack.defaultInstance)))
          case 8010 =>
            __leave = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __leave.getOrElse(netmsg.game.MLeave.defaultInstance)))
          case 8018 =>
            __toggleWaitingForRoundEnd = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __toggleWaitingForRoundEnd.getOrElse(netmsg.game.MToggleWaitingForRoundEnd.defaultInstance)))
          case 8026 =>
            __concede = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __concede.getOrElse(netmsg.game.MConcede.defaultInstance)))
          case tag => __input.skipField(tag)
        }
      }
      netmsg.game.FromClient(
          warp = __warp,
          move = __move,
          attackPos = __attackPos,
          attack = __attack,
          special = __special,
          moveAttack = __moveAttack,
          leave = __leave,
          toggleWaitingForRoundEnd = __toggleWaitingForRoundEnd,
          concede = __concede
      )
    }
    def getWarp: netmsg.game.MWarp = warp.getOrElse(netmsg.game.MWarp.defaultInstance)
    def clearWarp: FromClient = copy(warp = None)
    def withWarp(__v: netmsg.game.MWarp): FromClient = copy(warp = Some(__v))
    def getMove: netmsg.game.MMove = move.getOrElse(netmsg.game.MMove.defaultInstance)
    def clearMove: FromClient = copy(move = None)
    def withMove(__v: netmsg.game.MMove): FromClient = copy(move = Some(__v))
    def getAttackPos: netmsg.game.MAttackPos = attackPos.getOrElse(netmsg.game.MAttackPos.defaultInstance)
    def clearAttackPos: FromClient = copy(attackPos = None)
    def withAttackPos(__v: netmsg.game.MAttackPos): FromClient = copy(attackPos = Some(__v))
    def getAttack: netmsg.game.MAttack = attack.getOrElse(netmsg.game.MAttack.defaultInstance)
    def clearAttack: FromClient = copy(attack = None)
    def withAttack(__v: netmsg.game.MAttack): FromClient = copy(attack = Some(__v))
    def getSpecial: netmsg.game.MSpecial = special.getOrElse(netmsg.game.MSpecial.defaultInstance)
    def clearSpecial: FromClient = copy(special = None)
    def withSpecial(__v: netmsg.game.MSpecial): FromClient = copy(special = Some(__v))
    def getMoveAttack: netmsg.game.MMoveAttack = moveAttack.getOrElse(netmsg.game.MMoveAttack.defaultInstance)
    def clearMoveAttack: FromClient = copy(moveAttack = None)
    def withMoveAttack(__v: netmsg.game.MMoveAttack): FromClient = copy(moveAttack = Some(__v))
    def getLeave: netmsg.game.MLeave = leave.getOrElse(netmsg.game.MLeave.defaultInstance)
    def clearLeave: FromClient = copy(leave = None)
    def withLeave(__v: netmsg.game.MLeave): FromClient = copy(leave = Some(__v))
    def getToggleWaitingForRoundEnd: netmsg.game.MToggleWaitingForRoundEnd = toggleWaitingForRoundEnd.getOrElse(netmsg.game.MToggleWaitingForRoundEnd.defaultInstance)
    def clearToggleWaitingForRoundEnd: FromClient = copy(toggleWaitingForRoundEnd = None)
    def withToggleWaitingForRoundEnd(__v: netmsg.game.MToggleWaitingForRoundEnd): FromClient = copy(toggleWaitingForRoundEnd = Some(__v))
    def getConcede: netmsg.game.MConcede = concede.getOrElse(netmsg.game.MConcede.defaultInstance)
    def clearConcede: FromClient = copy(concede = None)
    def withConcede(__v: netmsg.game.MConcede): FromClient = copy(concede = Some(__v))
    def getField(__field: Descriptors.FieldDescriptor): Any = {
      __field.number match {
        case 1 => warp
        case 2 => move
        case 3 => attackPos
        case 4 => attack
        case 5 => special
        case 6 => moveAttack
        case 1001 => leave
        case 1002 => toggleWaitingForRoundEnd
        case 1003 => concede
      }
    }
    def companion = netmsg.game.FromClient
}

object FromClient extends com.trueaccord.scalapb.GeneratedMessageCompanion[FromClient]  {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[FromClient]  = this
  def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.FromClient = netmsg.game.FromClient(
    warp = fieldsMap.getOrElse(1, None).asInstanceOf[Option[netmsg.game.MWarp]],
    move = fieldsMap.getOrElse(2, None).asInstanceOf[Option[netmsg.game.MMove]],
    attackPos = fieldsMap.getOrElse(3, None).asInstanceOf[Option[netmsg.game.MAttackPos]],
    attack = fieldsMap.getOrElse(4, None).asInstanceOf[Option[netmsg.game.MAttack]],
    special = fieldsMap.getOrElse(5, None).asInstanceOf[Option[netmsg.game.MSpecial]],
    moveAttack = fieldsMap.getOrElse(6, None).asInstanceOf[Option[netmsg.game.MMoveAttack]],
    leave = fieldsMap.getOrElse(1001, None).asInstanceOf[Option[netmsg.game.MLeave]],
    toggleWaitingForRoundEnd = fieldsMap.getOrElse(1002, None).asInstanceOf[Option[netmsg.game.MToggleWaitingForRoundEnd]],
    concede = fieldsMap.getOrElse(1003, None).asInstanceOf[Option[netmsg.game.MConcede]]
  )
  lazy val descriptor = new Descriptors.MessageDescriptor("FromClient", this,
    None, m = Seq(),
    e = Seq(),
    f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.FromClient"))
  lazy val defaultInstance = netmsg.game.FromClient(
  )
  implicit class FromClientLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, FromClient]) extends com.trueaccord.lenses.ObjectLens[UpperPB, FromClient](_l) {
    def warp: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MWarp] = field(_.getWarp)((c_, f_) => c_.copy(warp = Some(f_)))
    def optionalWarp: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MWarp]] = field(_.warp)((c_, f_) => c_.copy(warp = f_))
    def move: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MMove] = field(_.getMove)((c_, f_) => c_.copy(move = Some(f_)))
    def optionalMove: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MMove]] = field(_.move)((c_, f_) => c_.copy(move = f_))
    def attackPos: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MAttackPos] = field(_.getAttackPos)((c_, f_) => c_.copy(attackPos = Some(f_)))
    def optionalAttackPos: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MAttackPos]] = field(_.attackPos)((c_, f_) => c_.copy(attackPos = f_))
    def attack: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MAttack] = field(_.getAttack)((c_, f_) => c_.copy(attack = Some(f_)))
    def optionalAttack: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MAttack]] = field(_.attack)((c_, f_) => c_.copy(attack = f_))
    def special: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MSpecial] = field(_.getSpecial)((c_, f_) => c_.copy(special = Some(f_)))
    def optionalSpecial: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MSpecial]] = field(_.special)((c_, f_) => c_.copy(special = f_))
    def moveAttack: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MMoveAttack] = field(_.getMoveAttack)((c_, f_) => c_.copy(moveAttack = Some(f_)))
    def optionalMoveAttack: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MMoveAttack]] = field(_.moveAttack)((c_, f_) => c_.copy(moveAttack = f_))
    def leave: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MLeave] = field(_.getLeave)((c_, f_) => c_.copy(leave = Some(f_)))
    def optionalLeave: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MLeave]] = field(_.leave)((c_, f_) => c_.copy(leave = f_))
    def toggleWaitingForRoundEnd: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MToggleWaitingForRoundEnd] = field(_.getToggleWaitingForRoundEnd)((c_, f_) => c_.copy(toggleWaitingForRoundEnd = Some(f_)))
    def optionalToggleWaitingForRoundEnd: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MToggleWaitingForRoundEnd]] = field(_.toggleWaitingForRoundEnd)((c_, f_) => c_.copy(toggleWaitingForRoundEnd = f_))
    def concede: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MConcede] = field(_.getConcede)((c_, f_) => c_.copy(concede = Some(f_)))
    def optionalConcede: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MConcede]] = field(_.concede)((c_, f_) => c_.copy(concede = f_))
  }
  final val WARP_FIELD_NUMBER = 1
  final val MOVE_FIELD_NUMBER = 2
  final val ATTACK_POS_FIELD_NUMBER = 3
  final val ATTACK_FIELD_NUMBER = 4
  final val SPECIAL_FIELD_NUMBER = 5
  final val MOVE_ATTACK_FIELD_NUMBER = 6
  final val LEAVE_FIELD_NUMBER = 1001
  final val TOGGLE_WAITING_FOR_ROUND_END_FIELD_NUMBER = 1002
  final val CONCEDE_FIELD_NUMBER = 1003
}
