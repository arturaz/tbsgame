// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!

package netmsg.game


import com.trueaccord.scalapb.Descriptors

final case class FromServer(
    events: Option[netmsg.game.MEvents] = None,
    error: Option[netmsg.game.MError] = None,
    init: Option[netmsg.game.MInit] = None
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[FromServer] with com.trueaccord.lenses.Updatable[FromServer] {
    lazy val serializedSize: Int = {
      var __size = 0
      if (events.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(events.get.serializedSize) + events.get.serializedSize }
      if (error.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(error.get.serializedSize) + error.get.serializedSize }
      if (init.isDefined) { __size += 2 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(init.get.serializedSize) + init.get.serializedSize }
      __size
    }
    def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
      events.foreach { v => 
        output.writeTag(1, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      error.foreach { v => 
        output.writeTag(2, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
      init.foreach { v => 
        output.writeTag(1000, 2)
        output.writeRawVarint32(v.serializedSize)
        v.writeTo(output)
      }
    }
    def mergeFrom(__input: com.google.protobuf.CodedInputStream): netmsg.game.FromServer = {
      var __events = this.events
      var __error = this.error
      var __init = this.init
      var _done__ = false
      while (!_done__) {
        val _tag__ = __input.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __events = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __events.getOrElse(netmsg.game.MEvents.defaultInstance)))
          case 18 =>
            __error = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __error.getOrElse(netmsg.game.MError.defaultInstance)))
          case 8002 =>
            __init = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __init.getOrElse(netmsg.game.MInit.defaultInstance)))
          case tag => __input.skipField(tag)
        }
      }
      netmsg.game.FromServer(
          events = __events,
          error = __error,
          init = __init
      )
    }
    def getEvents: netmsg.game.MEvents = events.getOrElse(netmsg.game.MEvents.defaultInstance)
    def clearEvents: FromServer = copy(events = None)
    def withEvents(__v: netmsg.game.MEvents): FromServer = copy(events = Some(__v))
    def getError: netmsg.game.MError = error.getOrElse(netmsg.game.MError.defaultInstance)
    def clearError: FromServer = copy(error = None)
    def withError(__v: netmsg.game.MError): FromServer = copy(error = Some(__v))
    def getInit: netmsg.game.MInit = init.getOrElse(netmsg.game.MInit.defaultInstance)
    def clearInit: FromServer = copy(init = None)
    def withInit(__v: netmsg.game.MInit): FromServer = copy(init = Some(__v))
    def getField(__field: Descriptors.FieldDescriptor): Any = {
      __field.number match {
        case 1 => events
        case 2 => error
        case 1000 => init
      }
    }
    def companion = netmsg.game.FromServer
}

object FromServer extends com.trueaccord.scalapb.GeneratedMessageCompanion[FromServer]  {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[FromServer]  = this
  def fromFieldsMap(fieldsMap: Map[Int, Any]): netmsg.game.FromServer = netmsg.game.FromServer(
    events = fieldsMap.getOrElse(1, None).asInstanceOf[Option[netmsg.game.MEvents]],
    error = fieldsMap.getOrElse(2, None).asInstanceOf[Option[netmsg.game.MError]],
    init = fieldsMap.getOrElse(1000, None).asInstanceOf[Option[netmsg.game.MInit]]
  )
  lazy val descriptor = new Descriptors.MessageDescriptor("FromServer", this,
    None, m = Seq(),
    e = Seq(),
    f = netmsg.game.InternalFields_game.internalFieldsFor("netmsg.game.FromServer"))
  lazy val defaultInstance = netmsg.game.FromServer(
  )
  implicit class FromServerLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, FromServer]) extends com.trueaccord.lenses.ObjectLens[UpperPB, FromServer](_l) {
    def events: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MEvents] = field(_.getEvents)((c_, f_) => c_.copy(events = Some(f_)))
    def optionalEvents: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MEvents]] = field(_.events)((c_, f_) => c_.copy(events = f_))
    def error: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MError] = field(_.getError)((c_, f_) => c_.copy(error = Some(f_)))
    def optionalError: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MError]] = field(_.error)((c_, f_) => c_.copy(error = f_))
    def init: com.trueaccord.lenses.Lens[UpperPB, netmsg.game.MInit] = field(_.getInit)((c_, f_) => c_.copy(init = Some(f_)))
    def optionalInit: com.trueaccord.lenses.Lens[UpperPB, Option[netmsg.game.MInit]] = field(_.init)((c_, f_) => c_.copy(init = f_))
  }
  final val EVENTS_FIELD_NUMBER = 1
  final val ERROR_FIELD_NUMBER = 2
  final val INIT_FIELD_NUMBER = 1000
}
